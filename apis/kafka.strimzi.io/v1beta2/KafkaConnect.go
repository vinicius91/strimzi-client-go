// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1beta2

import (
	"encoding/json"
	"fmt"
	"reflect"
	"regexp"

	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// KafkaConnect
type KafkaConnect struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// The specification of the Kafka Connect cluster.
	Spec *KafkaConnectSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`

	// The status of the Kafka Connect cluster.
	Status *KafkaConnectStatus `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`
}

// +kubebuilder:object:root=true
// KafkaConnectList contains a list of KafkaConnect instances.
type KafkaConnectList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`

	// A list of KafkaConnect objects.
	Items []KafkaConnect `json:"items,omitempty"`
}

// The specification of the Kafka Connect cluster.
// +kubebuilder:object:generate=true
type KafkaConnectSpec struct {
	// Authentication configuration for Kafka Connect.
	Authentication *KafkaConnectSpecAuthentication `json:"authentication,omitempty" yaml:"authentication,omitempty" mapstructure:"authentication,omitempty"`

	// Bootstrap servers to connect to. This should be given as a comma separated list
	// of _<hostname>_:_<port>_ pairs.
	BootstrapServers string `json:"bootstrapServers" yaml:"bootstrapServers" mapstructure:"bootstrapServers"`

	// Configures how the Connect container image should be built. Optional.
	Build *KafkaConnectSpecBuild `json:"build,omitempty" yaml:"build,omitempty" mapstructure:"build,omitempty"`

	// The image of the init container used for initializing the `client.rack`.
	ClientRackInitImage *string `json:"clientRackInitImage,omitempty" yaml:"clientRackInitImage,omitempty" mapstructure:"clientRackInitImage,omitempty"`

	// The Kafka Connect configuration. Properties with the following prefixes cannot
	// be set: ssl., sasl., security., listeners, plugin.path, rest.,
	// bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes
	// (with the exception of: ssl.endpoint.identification.algorithm,
	// ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
	Config *apiextensions.JSON `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to
	// configure connectors.
	ExternalConfiguration *KafkaConnectSpecExternalConfiguration `json:"externalConfiguration,omitempty" yaml:"externalConfiguration,omitempty" mapstructure:"externalConfiguration,omitempty"`

	// The container image used for Kafka Connect pods. If no image name is explicitly
	// specified, it is determined based on the `spec.version` configuration. The
	// image names are specifically mapped to corresponding versions in the Cluster
	// Operator configuration.
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// JMX Options.
	JmxOptions *KafkaConnectSpecJmxOptions `json:"jmxOptions,omitempty" yaml:"jmxOptions,omitempty" mapstructure:"jmxOptions,omitempty"`

	// JVM Options for pods.
	JvmOptions *KafkaConnectSpecJvmOptions `json:"jvmOptions,omitempty" yaml:"jvmOptions,omitempty" mapstructure:"jvmOptions,omitempty"`

	// Pod liveness checking.
	LivenessProbe *KafkaConnectSpecLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// Logging configuration for Kafka Connect.
	Logging *KafkaConnectSpecLogging `json:"logging,omitempty" yaml:"logging,omitempty" mapstructure:"logging,omitempty"`

	// Metrics configuration. Only `jmxPrometheusExporter` can be configured, as this
	// component does not yet support `strimziMetricsReporter`.
	MetricsConfig *KafkaConnectSpecMetricsConfig `json:"metricsConfig,omitempty" yaml:"metricsConfig,omitempty" mapstructure:"metricsConfig,omitempty"`

	// List of connector plugins to mount into the `KafkaConnect` pod.
	Plugins []KafkaConnectSpecPluginsElem `json:"plugins,omitempty" yaml:"plugins,omitempty" mapstructure:"plugins,omitempty"`

	// Configuration of the node label which will be used as the `client.rack`
	// consumer configuration.
	Rack *KafkaConnectSpecRack `json:"rack,omitempty" yaml:"rack,omitempty" mapstructure:"rack,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaConnectSpecReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// The number of pods in the Kafka Connect group. Defaults to `3`.
	Replicas *int32 `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// The maximum limits for CPU and memory resources and the requested initial
	// resources.
	Resources *KafkaConnectSpecResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Template for Kafka Connect and Kafka MirrorMaker 2 resources. The template
	// allows users to specify how the `Pods`, `Service`, and other services are
	// generated.
	Template *KafkaConnectSpecTemplate `json:"template,omitempty" yaml:"template,omitempty" mapstructure:"template,omitempty"`

	// TLS configuration.
	Tls *KafkaConnectSpecTls `json:"tls,omitempty" yaml:"tls,omitempty" mapstructure:"tls,omitempty"`

	// The configuration of tracing in Kafka Connect.
	Tracing *KafkaConnectSpecTracing `json:"tracing,omitempty" yaml:"tracing,omitempty" mapstructure:"tracing,omitempty"`

	// The Kafka Connect version. Defaults to the latest version. Consult the user
	// documentation to understand the process required to upgrade or downgrade the
	// version.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// Authentication configuration for Kafka Connect.
// +kubebuilder:object:generate=true
type KafkaConnectSpecAuthentication struct {
	// Link to Kubernetes Secret containing the access token which was obtained from
	// the authorization server.
	AccessToken *KafkaConnectSpecAuthenticationAccessToken `json:"accessToken,omitempty" yaml:"accessToken,omitempty" mapstructure:"accessToken,omitempty"`

	// Configure whether access token should be treated as JWT. This should be set to
	// `false` if the authorization server returns opaque tokens. Defaults to `true`.
	AccessTokenIsJwt *bool `json:"accessTokenIsJwt,omitempty" yaml:"accessTokenIsJwt,omitempty" mapstructure:"accessTokenIsJwt,omitempty"`

	// Path to the token file containing an access token to be used for
	// authentication.
	AccessTokenLocation *string `json:"accessTokenLocation,omitempty" yaml:"accessTokenLocation,omitempty" mapstructure:"accessTokenLocation,omitempty"`

	// OAuth audience to use when authenticating against the authorization server.
	// Some authorization servers require the audience to be explicitly set. The
	// possible values depend on how the authorization server is configured. By
	// default, `audience` is not specified when performing the token endpoint
	// request.
	Audience *string `json:"audience,omitempty" yaml:"audience,omitempty" mapstructure:"audience,omitempty"`

	// Reference to the `Secret` which holds the certificate and private key pair.
	CertificateAndKey *KafkaConnectSpecAuthenticationCertificateAndKey `json:"certificateAndKey,omitempty" yaml:"certificateAndKey,omitempty" mapstructure:"certificateAndKey,omitempty"`

	// Link to Kubernetes secret containing the client assertion which was manually
	// configured for the client.
	ClientAssertion *KafkaConnectSpecAuthenticationClientAssertion `json:"clientAssertion,omitempty" yaml:"clientAssertion,omitempty" mapstructure:"clientAssertion,omitempty"`

	// Path to the file containing the client assertion to be used for authentication.
	ClientAssertionLocation *string `json:"clientAssertionLocation,omitempty" yaml:"clientAssertionLocation,omitempty" mapstructure:"clientAssertionLocation,omitempty"`

	// The client assertion type. If not set, and either `clientAssertion` or
	// `clientAssertionLocation` is configured, this value defaults to
	// `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`.
	ClientAssertionType *string `json:"clientAssertionType,omitempty" yaml:"clientAssertionType,omitempty" mapstructure:"clientAssertionType,omitempty"`

	// OAuth Client ID which the Kafka client can use to authenticate against the
	// OAuth server and use the token endpoint URI.
	ClientId *string `json:"clientId,omitempty" yaml:"clientId,omitempty" mapstructure:"clientId,omitempty"`

	// Link to Kubernetes Secret containing the OAuth client secret which the Kafka
	// client can use to authenticate against the OAuth server and use the token
	// endpoint URI.
	ClientSecret *KafkaConnectSpecAuthenticationClientSecret `json:"clientSecret,omitempty" yaml:"clientSecret,omitempty" mapstructure:"clientSecret,omitempty"`

	// The connect timeout in seconds when connecting to authorization server. If not
	// set, the effective connect timeout is 60 seconds.
	ConnectTimeoutSeconds *int32 `json:"connectTimeoutSeconds,omitempty" yaml:"connectTimeoutSeconds,omitempty" mapstructure:"connectTimeoutSeconds,omitempty"`

	// Enable or disable TLS hostname verification. Default value is `false`.
	DisableTlsHostnameVerification *bool `json:"disableTlsHostnameVerification,omitempty" yaml:"disableTlsHostnameVerification,omitempty" mapstructure:"disableTlsHostnameVerification,omitempty"`

	// Enable or disable OAuth metrics. Default value is `false`.
	EnableMetrics *bool `json:"enableMetrics,omitempty" yaml:"enableMetrics,omitempty" mapstructure:"enableMetrics,omitempty"`

	// The maximum number of retries to attempt if an initial HTTP request fails. If
	// not set, the default is to not attempt any retries.
	HttpRetries *int32 `json:"httpRetries,omitempty" yaml:"httpRetries,omitempty" mapstructure:"httpRetries,omitempty"`

	// The pause to take before retrying a failed HTTP request. If not set, the
	// default is to not pause at all but to immediately repeat a request.
	HttpRetryPauseMs *int32 `json:"httpRetryPauseMs,omitempty" yaml:"httpRetryPauseMs,omitempty" mapstructure:"httpRetryPauseMs,omitempty"`

	// Whether the Accept header should be set in requests to the authorization
	// servers. The default value is `true`.
	IncludeAcceptHeader *bool `json:"includeAcceptHeader,omitempty" yaml:"includeAcceptHeader,omitempty" mapstructure:"includeAcceptHeader,omitempty"`

	// Set or limit time-to-live of the access tokens to the specified number of
	// seconds. This should be set if the authorization server returns opaque tokens.
	MaxTokenExpirySeconds *int32 `json:"maxTokenExpirySeconds,omitempty" yaml:"maxTokenExpirySeconds,omitempty" mapstructure:"maxTokenExpirySeconds,omitempty"`

	// Reference to the `Secret` which holds the password.
	PasswordSecret *KafkaConnectSpecAuthenticationPasswordSecret `json:"passwordSecret,omitempty" yaml:"passwordSecret,omitempty" mapstructure:"passwordSecret,omitempty"`

	// The read timeout in seconds when connecting to authorization server. If not
	// set, the effective read timeout is 60 seconds.
	ReadTimeoutSeconds *int32 `json:"readTimeoutSeconds,omitempty" yaml:"readTimeoutSeconds,omitempty" mapstructure:"readTimeoutSeconds,omitempty"`

	// Link to Kubernetes Secret containing the refresh token which can be used to
	// obtain access token from the authorization server.
	RefreshToken *KafkaConnectSpecAuthenticationRefreshToken `json:"refreshToken,omitempty" yaml:"refreshToken,omitempty" mapstructure:"refreshToken,omitempty"`

	// SASL extensions parameters.
	SaslExtensions map[string]string `json:"saslExtensions,omitempty" yaml:"saslExtensions,omitempty" mapstructure:"saslExtensions,omitempty"`

	// OAuth scope to use when authenticating against the authorization server. Some
	// authorization servers require this to be set. The possible values depend on how
	// authorization server is configured. By default `scope` is not specified when
	// doing the token endpoint request.
	Scope *string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Trusted certificates for TLS connection to the OAuth server.
	TlsTrustedCertificates []KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem `json:"tlsTrustedCertificates,omitempty" yaml:"tlsTrustedCertificates,omitempty" mapstructure:"tlsTrustedCertificates,omitempty"`

	// Authorization server token endpoint URI.
	TokenEndpointUri *string `json:"tokenEndpointUri,omitempty" yaml:"tokenEndpointUri,omitempty" mapstructure:"tokenEndpointUri,omitempty"`

	// Authentication type. Currently the supported types are `tls`, `scram-sha-256`,
	// `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512`
	// types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication,
	// respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses
	// SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication.
	// The `tls` type is supported only over TLS connections.
	Type KafkaConnectSpecAuthenticationType `json:"type" yaml:"type" mapstructure:"type"`

	// Username used for the authentication.
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`
}

// Link to Kubernetes Secret containing the access token which was obtained from
// the authorization server.
// +kubebuilder:object:generate=true
type KafkaConnectSpecAuthenticationAccessToken struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationAccessToken) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaConnectSpecAuthenticationAccessToken: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaConnectSpecAuthenticationAccessToken: required")
	}
	type Plain KafkaConnectSpecAuthenticationAccessToken
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationAccessToken(plain)
	return nil
}

// Reference to the `Secret` which holds the certificate and private key pair.
// +kubebuilder:object:generate=true
type KafkaConnectSpecAuthenticationCertificateAndKey struct {
	// The name of the file certificate in the Secret.
	Certificate string `json:"certificate" yaml:"certificate" mapstructure:"certificate"`

	// The name of the private key in the Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationCertificateAndKey) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["certificate"]; raw != nil && !ok {
		return fmt.Errorf("field certificate in KafkaConnectSpecAuthenticationCertificateAndKey: required")
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaConnectSpecAuthenticationCertificateAndKey: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaConnectSpecAuthenticationCertificateAndKey: required")
	}
	type Plain KafkaConnectSpecAuthenticationCertificateAndKey
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationCertificateAndKey(plain)
	return nil
}

// Link to Kubernetes secret containing the client assertion which was manually
// configured for the client.
// +kubebuilder:object:generate=true
type KafkaConnectSpecAuthenticationClientAssertion struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationClientAssertion) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaConnectSpecAuthenticationClientAssertion: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaConnectSpecAuthenticationClientAssertion: required")
	}
	type Plain KafkaConnectSpecAuthenticationClientAssertion
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationClientAssertion(plain)
	return nil
}

// Link to Kubernetes Secret containing the OAuth client secret which the Kafka
// client can use to authenticate against the OAuth server and use the token
// endpoint URI.
// +kubebuilder:object:generate=true
type KafkaConnectSpecAuthenticationClientSecret struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationClientSecret) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaConnectSpecAuthenticationClientSecret: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaConnectSpecAuthenticationClientSecret: required")
	}
	type Plain KafkaConnectSpecAuthenticationClientSecret
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationClientSecret(plain)
	return nil
}

// Reference to the `Secret` which holds the password.
// +kubebuilder:object:generate=true
type KafkaConnectSpecAuthenticationPasswordSecret struct {
	// The name of the key in the Secret under which the password is stored.
	Password string `json:"password" yaml:"password" mapstructure:"password"`

	// The name of the Secret containing the password.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationPasswordSecret) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["password"]; raw != nil && !ok {
		return fmt.Errorf("field password in KafkaConnectSpecAuthenticationPasswordSecret: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaConnectSpecAuthenticationPasswordSecret: required")
	}
	type Plain KafkaConnectSpecAuthenticationPasswordSecret
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationPasswordSecret(plain)
	return nil
}

// Link to Kubernetes Secret containing the refresh token which can be used to
// obtain access token from the authorization server.
// +kubebuilder:object:generate=true
type KafkaConnectSpecAuthenticationRefreshToken struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationRefreshToken) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaConnectSpecAuthenticationRefreshToken: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaConnectSpecAuthenticationRefreshToken: required")
	}
	type Plain KafkaConnectSpecAuthenticationRefreshToken
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationRefreshToken(plain)
	return nil
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem struct {
	// The name of the file certificate in the secret.
	Certificate *string `json:"certificate,omitempty" yaml:"certificate,omitempty" mapstructure:"certificate,omitempty"`

	// Pattern for the certificate files in the secret. Use the
	// link:https://en.wikipedia.org/wiki/Glob_(programming)[_glob syntax_] for the
	// pattern. All files in the secret that match the pattern are used.
	Pattern *string `json:"pattern,omitempty" yaml:"pattern,omitempty" mapstructure:"pattern,omitempty"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem: required")
	}
	type Plain KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthenticationTlsTrustedCertificatesElem(plain)
	return nil
}

type KafkaConnectSpecAuthenticationType string

const KafkaConnectSpecAuthenticationTypeOauth KafkaConnectSpecAuthenticationType = "oauth"
const KafkaConnectSpecAuthenticationTypePlain KafkaConnectSpecAuthenticationType = "plain"
const KafkaConnectSpecAuthenticationTypeScramSha256 KafkaConnectSpecAuthenticationType = "scram-sha-256"
const KafkaConnectSpecAuthenticationTypeScramSha512 KafkaConnectSpecAuthenticationType = "scram-sha-512"
const KafkaConnectSpecAuthenticationTypeTls KafkaConnectSpecAuthenticationType = "tls"

var enumValues_KafkaConnectSpecAuthenticationType = []interface{}{
	"tls",
	"scram-sha-256",
	"scram-sha-512",
	"plain",
	"oauth",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthenticationType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecAuthenticationType, v)
	}
	*j = KafkaConnectSpecAuthenticationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecAuthentication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaConnectSpecAuthentication: required")
	}
	type Plain KafkaConnectSpecAuthentication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecAuthentication(plain)
	return nil
}

// Configures how the Connect container image should be built. Optional.
// +kubebuilder:object:generate=true
type KafkaConnectSpecBuild struct {
	// Configures where should the newly built image be stored. Required.
	Output KafkaConnectSpecBuildOutput `json:"output" yaml:"output" mapstructure:"output"`

	// List of connector plugins which should be added to the Kafka Connect. Required.
	Plugins []KafkaConnectSpecBuildPluginsElem `json:"plugins" yaml:"plugins" mapstructure:"plugins"`

	// CPU and memory resources to reserve for the build.
	Resources *KafkaConnectSpecBuildResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`
}

// Configures where should the newly built image be stored. Required.
// +kubebuilder:object:generate=true
type KafkaConnectSpecBuildOutput struct {
	// Configures additional options which will be passed to the Kaniko executor when
	// building the new Connect image. Allowed options are: --customPlatform,
	// --custom-platform, --insecure, --insecure-pull, --insecure-registry,
	// --log-format, --log-timestamp, --registry-mirror, --reproducible,
	// --single-snapshot, --skip-tls-verify, --skip-tls-verify-pull,
	// --skip-tls-verify-registry, --verbosity, --snapshotMode, --use-new-run,
	// --registry-certificate, --registry-client-cert, --ignore-path. These options
	// will be used only on Kubernetes where the Kaniko executor is used. They will be
	// ignored on OpenShift. The options are described in the
	// link:https://github.com/GoogleContainerTools/kaniko[Kaniko GitHub repository^].
	// Changing this field does not trigger new build of the Kafka Connect image.
	AdditionalKanikoOptions []string `json:"additionalKanikoOptions,omitempty" yaml:"additionalKanikoOptions,omitempty" mapstructure:"additionalKanikoOptions,omitempty"`

	// The name of the image which will be built. Required.
	Image string `json:"image" yaml:"image" mapstructure:"image"`

	// Container Registry Secret with the credentials for pushing the newly built
	// image.
	PushSecret *string `json:"pushSecret,omitempty" yaml:"pushSecret,omitempty" mapstructure:"pushSecret,omitempty"`

	// Output type. Must be either `docker` for pushing the newly build image to
	// Docker compatible registry or `imagestream` for pushing the image to OpenShift
	// ImageStream. Required.
	Type KafkaConnectSpecBuildOutputType `json:"type" yaml:"type" mapstructure:"type"`
}

type KafkaConnectSpecBuildOutputType string

const KafkaConnectSpecBuildOutputTypeDocker KafkaConnectSpecBuildOutputType = "docker"
const KafkaConnectSpecBuildOutputTypeImagestream KafkaConnectSpecBuildOutputType = "imagestream"

var enumValues_KafkaConnectSpecBuildOutputType = []interface{}{
	"docker",
	"imagestream",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildOutputType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecBuildOutputType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecBuildOutputType, v)
	}
	*j = KafkaConnectSpecBuildOutputType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildOutput) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["image"]; raw != nil && !ok {
		return fmt.Errorf("field image in KafkaConnectSpecBuildOutput: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaConnectSpecBuildOutput: required")
	}
	type Plain KafkaConnectSpecBuildOutput
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecBuildOutput(plain)
	return nil
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecBuildPluginsElem struct {
	// List of artifacts which belong to this connector plugin. Required.
	Artifacts []KafkaConnectSpecBuildPluginsElemArtifactsElem `json:"artifacts" yaml:"artifacts" mapstructure:"artifacts"`

	// The unique name of the connector plugin. Will be used to generate the path
	// where the connector artifacts will be stored. The name has to be unique within
	// the KafkaConnect resource. The name has to follow the following pattern:
	// `^[a-z][-_a-z0-9]*[a-z]$`. Required.
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecBuildPluginsElemArtifactsElem struct {
	// Maven artifact id. Applicable to the `maven` artifact type only.
	Artifact *string `json:"artifact,omitempty" yaml:"artifact,omitempty" mapstructure:"artifact,omitempty"`

	// Name under which the artifact will be stored.
	FileName *string `json:"fileName,omitempty" yaml:"fileName,omitempty" mapstructure:"fileName,omitempty"`

	// Maven group id. Applicable to the `maven` artifact type only.
	Group *string `json:"group,omitempty" yaml:"group,omitempty" mapstructure:"group,omitempty"`

	// By default, connections using TLS are verified to check they are secure. The
	// server certificate used must be valid, trusted, and contain the server name. By
	// setting this option to `true`, all TLS verification is disabled and the
	// artifact will be downloaded, even when the server is considered insecure.
	Insecure *bool `json:"insecure,omitempty" yaml:"insecure,omitempty" mapstructure:"insecure,omitempty"`

	// Maven repository to download the artifact from. Applicable to the `maven`
	// artifact type only.
	Repository *string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`

	// SHA512 checksum of the artifact. Optional. If specified, the checksum will be
	// verified while building the new container. If not specified, the downloaded
	// artifact will not be verified. Not applicable to the `maven` artifact type.
	Sha512Sum *string `json:"sha512sum,omitempty" yaml:"sha512sum,omitempty" mapstructure:"sha512sum,omitempty"`

	// Artifact type. Currently, the supported artifact types are `tgz`, `jar`, `zip`,
	// `other` and `maven`.
	Type KafkaConnectSpecBuildPluginsElemArtifactsElemType `json:"type" yaml:"type" mapstructure:"type"`

	// URL of the artifact which will be downloaded. Strimzi does not do any security
	// scanning of the downloaded artifacts. For security reasons, you should first
	// verify the artifacts manually and configure the checksum verification to make
	// sure the same artifact is used in the automated build. Required for `jar`,
	// `zip`, `tgz` and `other` artifacts. Not applicable to the `maven` artifact
	// type.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`

	// Maven version number. Applicable to the `maven` artifact type only.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type KafkaConnectSpecBuildPluginsElemArtifactsElemType string

const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeJar KafkaConnectSpecBuildPluginsElemArtifactsElemType = "jar"
const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeMaven KafkaConnectSpecBuildPluginsElemArtifactsElemType = "maven"
const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeOther KafkaConnectSpecBuildPluginsElemArtifactsElemType = "other"
const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeTgz KafkaConnectSpecBuildPluginsElemArtifactsElemType = "tgz"
const KafkaConnectSpecBuildPluginsElemArtifactsElemTypeZip KafkaConnectSpecBuildPluginsElemArtifactsElemType = "zip"

var enumValues_KafkaConnectSpecBuildPluginsElemArtifactsElemType = []interface{}{
	"jar",
	"tgz",
	"zip",
	"maven",
	"other",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildPluginsElemArtifactsElemType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecBuildPluginsElemArtifactsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecBuildPluginsElemArtifactsElemType, v)
	}
	*j = KafkaConnectSpecBuildPluginsElemArtifactsElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildPluginsElemArtifactsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaConnectSpecBuildPluginsElemArtifactsElem: required")
	}
	type Plain KafkaConnectSpecBuildPluginsElemArtifactsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Url != nil {
		if matched, _ := regexp.MatchString(`^(https?|ftp)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$`, string(*plain.Url)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Url", `^(https?|ftp)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]$`)
		}
	}
	*j = KafkaConnectSpecBuildPluginsElemArtifactsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuildPluginsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["artifacts"]; raw != nil && !ok {
		return fmt.Errorf("field artifacts in KafkaConnectSpecBuildPluginsElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in KafkaConnectSpecBuildPluginsElem: required")
	}
	type Plain KafkaConnectSpecBuildPluginsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-z0-9][-_a-z0-9]*[a-z0-9]$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Name", `^[a-z0-9][-_a-z0-9]*[a-z0-9]$`)
	}
	*j = KafkaConnectSpecBuildPluginsElem(plain)
	return nil
}

// CPU and memory resources to reserve for the build.
// +kubebuilder:object:generate=true
type KafkaConnectSpecBuildResources struct {
	// Claims corresponds to the JSON schema field "claims".
	Claims []KafkaConnectSpecBuildResourcesClaimsElem `json:"claims,omitempty" yaml:"claims,omitempty" mapstructure:"claims,omitempty"`

	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecBuildResourcesClaimsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Request corresponds to the JSON schema field "request".
	Request *string `json:"request,omitempty" yaml:"request,omitempty" mapstructure:"request,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecBuild) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["output"]; raw != nil && !ok {
		return fmt.Errorf("field output in KafkaConnectSpecBuild: required")
	}
	if _, ok := raw["plugins"]; raw != nil && !ok {
		return fmt.Errorf("field plugins in KafkaConnectSpecBuild: required")
	}
	type Plain KafkaConnectSpecBuild
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecBuild(plain)
	return nil
}

// Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to
// configure connectors.
// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfiguration struct {
	// Makes data from a Secret or ConfigMap available in the Kafka Connect pods as
	// environment variables.
	Env []KafkaConnectSpecExternalConfigurationEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// Makes data from a Secret or ConfigMap available in the Kafka Connect pods as
	// volumes.
	Volumes []KafkaConnectSpecExternalConfigurationVolumesElem `json:"volumes,omitempty" yaml:"volumes,omitempty" mapstructure:"volumes,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationEnvElem struct {
	// Name of the environment variable which will be passed to the Kafka Connect
	// pods. The name of the environment variable cannot start with `KAFKA_` or
	// `STRIMZI_`.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Value of the environment variable which will be passed to the Kafka Connect
	// pods. It can be passed either as a reference to Secret or ConfigMap field. The
	// field has to specify exactly one Secret or ConfigMap.
	ValueFrom KafkaConnectSpecExternalConfigurationEnvElemValueFrom `json:"valueFrom" yaml:"valueFrom" mapstructure:"valueFrom"`
}

// Value of the environment variable which will be passed to the Kafka Connect
// pods. It can be passed either as a reference to Secret or ConfigMap field. The
// field has to specify exactly one Secret or ConfigMap.
// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationEnvElemValueFrom struct {
	// Reference to a key in a ConfigMap.
	ConfigMapKeyRef *KafkaConnectSpecExternalConfigurationEnvElemValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`

	// Reference to a key in a Secret.
	SecretKeyRef *KafkaConnectSpecExternalConfigurationEnvElemValueFromSecretKeyRef `json:"secretKeyRef,omitempty" yaml:"secretKeyRef,omitempty" mapstructure:"secretKeyRef,omitempty"`
}

// Reference to a key in a ConfigMap.
// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationEnvElemValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Reference to a key in a Secret.
// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationEnvElemValueFromSecretKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecExternalConfigurationEnvElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in KafkaConnectSpecExternalConfigurationEnvElem: required")
	}
	if _, ok := raw["valueFrom"]; raw != nil && !ok {
		return fmt.Errorf("field valueFrom in KafkaConnectSpecExternalConfigurationEnvElem: required")
	}
	type Plain KafkaConnectSpecExternalConfigurationEnvElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecExternalConfigurationEnvElem(plain)
	return nil
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationVolumesElem struct {
	// Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be
	// specified.
	ConfigMap *KafkaConnectSpecExternalConfigurationVolumesElemConfigMap `json:"configMap,omitempty" yaml:"configMap,omitempty" mapstructure:"configMap,omitempty"`

	// Name of the volume which will be added to the Kafka Connect pods.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be
	// specified.
	Secret *KafkaConnectSpecExternalConfigurationVolumesElemSecret `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`
}

// Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be
// specified.
// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationVolumesElemConfigMap struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty" yaml:"defaultMode,omitempty" mapstructure:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaConnectSpecExternalConfigurationVolumesElemConfigMapItemsElem `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationVolumesElemConfigMapItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

// Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be
// specified.
// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationVolumesElemSecret struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty" yaml:"defaultMode,omitempty" mapstructure:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaConnectSpecExternalConfigurationVolumesElemSecretItemsElem `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// SecretName corresponds to the JSON schema field "secretName".
	SecretName *string `json:"secretName,omitempty" yaml:"secretName,omitempty" mapstructure:"secretName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecExternalConfigurationVolumesElemSecretItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecExternalConfigurationVolumesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in KafkaConnectSpecExternalConfigurationVolumesElem: required")
	}
	type Plain KafkaConnectSpecExternalConfigurationVolumesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecExternalConfigurationVolumesElem(plain)
	return nil
}

// JMX Options.
// +kubebuilder:object:generate=true
type KafkaConnectSpecJmxOptions struct {
	// Authentication configuration for connecting to the JMX port.
	Authentication *KafkaConnectSpecJmxOptionsAuthentication `json:"authentication,omitempty" yaml:"authentication,omitempty" mapstructure:"authentication,omitempty"`
}

// Authentication configuration for connecting to the JMX port.
// +kubebuilder:object:generate=true
type KafkaConnectSpecJmxOptionsAuthentication struct {
	// Authentication type. Currently the only supported types are
	// `password`.`password` type creates a username and protected port with no TLS.
	Type KafkaConnectSpecJmxOptionsAuthenticationType `json:"type" yaml:"type" mapstructure:"type"`
}

type KafkaConnectSpecJmxOptionsAuthenticationType string

const KafkaConnectSpecJmxOptionsAuthenticationTypePassword KafkaConnectSpecJmxOptionsAuthenticationType = "password"

var enumValues_KafkaConnectSpecJmxOptionsAuthenticationType = []interface{}{
	"password",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecJmxOptionsAuthenticationType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecJmxOptionsAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecJmxOptionsAuthenticationType, v)
	}
	*j = KafkaConnectSpecJmxOptionsAuthenticationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecJmxOptionsAuthentication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaConnectSpecJmxOptionsAuthentication: required")
	}
	type Plain KafkaConnectSpecJmxOptionsAuthentication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecJmxOptionsAuthentication(plain)
	return nil
}

// JVM Options for pods.
// +kubebuilder:object:generate=true
type KafkaConnectSpecJvmOptions struct {
	// A map of -XX options to the JVM.
	XX map[string]string `json:"-XX,omitempty" yaml:"-XX,omitempty" mapstructure:"-XX,omitempty"`

	// -Xms option to to the JVM.
	Xms *string `json:"-Xms,omitempty" yaml:"-Xms,omitempty" mapstructure:"-Xms,omitempty"`

	// -Xmx option to to the JVM.
	Xmx *string `json:"-Xmx,omitempty" yaml:"-Xmx,omitempty" mapstructure:"-Xmx,omitempty"`

	// Specifies whether the Garbage Collection logging is enabled. The default is
	// false.
	GcLoggingEnabled *bool `json:"gcLoggingEnabled,omitempty" yaml:"gcLoggingEnabled,omitempty" mapstructure:"gcLoggingEnabled,omitempty"`

	// A map of additional system properties which will be passed using the `-D`
	// option to the JVM.
	JavaSystemProperties []KafkaConnectSpecJvmOptionsJavaSystemPropertiesElem `json:"javaSystemProperties,omitempty" yaml:"javaSystemProperties,omitempty" mapstructure:"javaSystemProperties,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecJvmOptionsJavaSystemPropertiesElem struct {
	// The system property name.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The system property value.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecJvmOptions) UnmarshalJSON(value []byte) error {
	type Plain KafkaConnectSpecJvmOptions
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Xms != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[mMgG]?$`, string(*plain.Xms)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Xms", `^[0-9]+[mMgG]?$`)
		}
	}
	if plain.Xmx != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[mMgG]?$`, string(*plain.Xmx)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Xmx", `^[0-9]+[mMgG]?$`)
		}
	}
	*j = KafkaConnectSpecJvmOptions(plain)
	return nil
}

// Pod liveness checking.
// +kubebuilder:object:generate=true
type KafkaConnectSpecLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecLivenessProbe) UnmarshalJSON(value []byte) error {
	type Plain KafkaConnectSpecLivenessProbe
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.FailureThreshold != nil && 1 > *plain.FailureThreshold {
		return fmt.Errorf("field %s: must be >= %v", "failureThreshold", 1)
	}
	if plain.InitialDelaySeconds != nil && 0 > *plain.InitialDelaySeconds {
		return fmt.Errorf("field %s: must be >= %v", "initialDelaySeconds", 0)
	}
	if plain.PeriodSeconds != nil && 1 > *plain.PeriodSeconds {
		return fmt.Errorf("field %s: must be >= %v", "periodSeconds", 1)
	}
	if plain.SuccessThreshold != nil && 1 > *plain.SuccessThreshold {
		return fmt.Errorf("field %s: must be >= %v", "successThreshold", 1)
	}
	if plain.TimeoutSeconds != nil && 1 > *plain.TimeoutSeconds {
		return fmt.Errorf("field %s: must be >= %v", "timeoutSeconds", 1)
	}
	*j = KafkaConnectSpecLivenessProbe(plain)
	return nil
}

// Logging configuration for Kafka Connect.
// +kubebuilder:object:generate=true
type KafkaConnectSpecLogging struct {
	// A Map from logger name to logger level.
	Loggers map[string]string `json:"loggers,omitempty" yaml:"loggers,omitempty" mapstructure:"loggers,omitempty"`

	// Logging type, must be either 'inline' or 'external'.
	Type KafkaConnectSpecLoggingType `json:"type" yaml:"type" mapstructure:"type"`

	// `ConfigMap` entry where the logging configuration is stored.
	ValueFrom *KafkaConnectSpecLoggingValueFrom `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty" mapstructure:"valueFrom,omitempty"`
}

type KafkaConnectSpecLoggingType string

const KafkaConnectSpecLoggingTypeExternal KafkaConnectSpecLoggingType = "external"
const KafkaConnectSpecLoggingTypeInline KafkaConnectSpecLoggingType = "inline"

var enumValues_KafkaConnectSpecLoggingType = []interface{}{
	"inline",
	"external",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecLoggingType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecLoggingType, v)
	}
	*j = KafkaConnectSpecLoggingType(v)
	return nil
}

// `ConfigMap` entry where the logging configuration is stored.
// +kubebuilder:object:generate=true
type KafkaConnectSpecLoggingValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaConnectSpecLoggingValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
// +kubebuilder:object:generate=true
type KafkaConnectSpecLoggingValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecLogging) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaConnectSpecLogging: required")
	}
	type Plain KafkaConnectSpecLogging
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecLogging(plain)
	return nil
}

// Metrics configuration. Only `jmxPrometheusExporter` can be configured, as this
// component does not yet support `strimziMetricsReporter`.
// +kubebuilder:object:generate=true
type KafkaConnectSpecMetricsConfig struct {
	// Metrics type. The supported types are `jmxPrometheusExporter` and
	// `strimziMetricsReporter`. Type `jmxPrometheusExporter` uses the Prometheus JMX
	// Exporter to expose Kafka JMX metrics in Prometheus format through an HTTP
	// endpoint. Type `strimziMetricsReporter` uses the Strimzi Metrics Reporter to
	// directly expose Kafka metrics in Prometheus format through an HTTP endpoint.
	Type KafkaConnectSpecMetricsConfigType `json:"type" yaml:"type" mapstructure:"type"`

	// ConfigMap entry where the Prometheus JMX Exporter configuration is stored.
	ValueFrom *KafkaConnectSpecMetricsConfigValueFrom `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty" mapstructure:"valueFrom,omitempty"`

	// Configuration values for the Strimzi Metrics Reporter.
	Values *KafkaConnectSpecMetricsConfigValues `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

type KafkaConnectSpecMetricsConfigType string

const KafkaConnectSpecMetricsConfigTypeJmxPrometheusExporter KafkaConnectSpecMetricsConfigType = "jmxPrometheusExporter"
const KafkaConnectSpecMetricsConfigTypeStrimziMetricsReporter KafkaConnectSpecMetricsConfigType = "strimziMetricsReporter"

var enumValues_KafkaConnectSpecMetricsConfigType = []interface{}{
	"jmxPrometheusExporter",
	"strimziMetricsReporter",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecMetricsConfigType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecMetricsConfigType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecMetricsConfigType, v)
	}
	*j = KafkaConnectSpecMetricsConfigType(v)
	return nil
}

// ConfigMap entry where the Prometheus JMX Exporter configuration is stored.
// +kubebuilder:object:generate=true
type KafkaConnectSpecMetricsConfigValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
// +kubebuilder:object:generate=true
type KafkaConnectSpecMetricsConfigValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Configuration values for the Strimzi Metrics Reporter.
// +kubebuilder:object:generate=true
type KafkaConnectSpecMetricsConfigValues struct {
	// A list of regex patterns to filter the metrics to collect. Should contain at
	// least one element.
	AllowList []string `json:"allowList,omitempty" yaml:"allowList,omitempty" mapstructure:"allowList,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecMetricsConfig) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaConnectSpecMetricsConfig: required")
	}
	type Plain KafkaConnectSpecMetricsConfig
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecMetricsConfig(plain)
	return nil
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecPluginsElem struct {
	// List of artifacts associated with this connector plugin. Required.
	Artifacts []KafkaConnectSpecPluginsElemArtifactsElem `json:"artifacts" yaml:"artifacts" mapstructure:"artifacts"`

	// A unique name for the connector plugin. This name is used to generate the mount
	// path for the connector artifacts. The name has to be unique within the
	// KafkaConnect resource. The name must be unique within the `KafkaConnect`
	// resource and match the pattern: `^[a-z][-_a-z0-9]*[a-z]$`. Required.
	Name string `json:"name" yaml:"name" mapstructure:"name"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecPluginsElemArtifactsElem struct {
	// Policy that determines when the container image (OCI artifact) is pulled.
	//
	// Possible values are:
	//
	// * `Always`: Always pull the image. If the pull fails, container creation fails.
	// * `Never`: Never pull the image. Use only a locally available image. Container
	// creation fails if the image isn’t present.
	// * `IfNotPresent`: Pull the image only if it’s not already available locally.
	// Container creation fails if the image isn’t present and the pull fails.
	//
	// Defaults to `Always` if `:latest` tag is specified, or `IfNotPresent`
	// otherwise.
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Reference to the container image (OCI artifact) containing the Kafka Connect
	// plugin. The image is mounted as a volume and provides the plugin binary.
	// Required.
	Reference string `json:"reference" yaml:"reference" mapstructure:"reference"`

	// Artifact type. Currently, the only supported artifact type is `image`.
	Type KafkaConnectSpecPluginsElemArtifactsElemType `json:"type" yaml:"type" mapstructure:"type"`
}

type KafkaConnectSpecPluginsElemArtifactsElemType string

const KafkaConnectSpecPluginsElemArtifactsElemTypeImage KafkaConnectSpecPluginsElemArtifactsElemType = "image"

var enumValues_KafkaConnectSpecPluginsElemArtifactsElemType = []interface{}{
	"image",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecPluginsElemArtifactsElemType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecPluginsElemArtifactsElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecPluginsElemArtifactsElemType, v)
	}
	*j = KafkaConnectSpecPluginsElemArtifactsElemType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecPluginsElemArtifactsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["reference"]; raw != nil && !ok {
		return fmt.Errorf("field reference in KafkaConnectSpecPluginsElemArtifactsElem: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaConnectSpecPluginsElemArtifactsElem: required")
	}
	type Plain KafkaConnectSpecPluginsElemArtifactsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecPluginsElemArtifactsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecPluginsElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["artifacts"]; raw != nil && !ok {
		return fmt.Errorf("field artifacts in KafkaConnectSpecPluginsElem: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in KafkaConnectSpecPluginsElem: required")
	}
	type Plain KafkaConnectSpecPluginsElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-z0-9][-_a-z0-9]*[a-z0-9]$`, string(plain.Name)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Name", `^[a-z0-9][-_a-z0-9]*[a-z0-9]$`)
	}
	*j = KafkaConnectSpecPluginsElem(plain)
	return nil
}

// Configuration of the node label which will be used as the `client.rack` consumer
// configuration.
// +kubebuilder:object:generate=true
type KafkaConnectSpecRack struct {
	// A key that matches labels assigned to the Kubernetes cluster nodes. The value
	// of the label is used to set a broker's `broker.rack` config, and the
	// `client.rack` config for Kafka Connect or MirrorMaker 2.
	TopologyKey string `json:"topologyKey" yaml:"topologyKey" mapstructure:"topologyKey"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecRack) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["topologyKey"]; raw != nil && !ok {
		return fmt.Errorf("field topologyKey in KafkaConnectSpecRack: required")
	}
	type Plain KafkaConnectSpecRack
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecRack(plain)
	return nil
}

// Pod readiness checking.
// +kubebuilder:object:generate=true
type KafkaConnectSpecReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecReadinessProbe) UnmarshalJSON(value []byte) error {
	type Plain KafkaConnectSpecReadinessProbe
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.FailureThreshold != nil && 1 > *plain.FailureThreshold {
		return fmt.Errorf("field %s: must be >= %v", "failureThreshold", 1)
	}
	if plain.InitialDelaySeconds != nil && 0 > *plain.InitialDelaySeconds {
		return fmt.Errorf("field %s: must be >= %v", "initialDelaySeconds", 0)
	}
	if plain.PeriodSeconds != nil && 1 > *plain.PeriodSeconds {
		return fmt.Errorf("field %s: must be >= %v", "periodSeconds", 1)
	}
	if plain.SuccessThreshold != nil && 1 > *plain.SuccessThreshold {
		return fmt.Errorf("field %s: must be >= %v", "successThreshold", 1)
	}
	if plain.TimeoutSeconds != nil && 1 > *plain.TimeoutSeconds {
		return fmt.Errorf("field %s: must be >= %v", "timeoutSeconds", 1)
	}
	*j = KafkaConnectSpecReadinessProbe(plain)
	return nil
}

// The maximum limits for CPU and memory resources and the requested initial
// resources.
// +kubebuilder:object:generate=true
type KafkaConnectSpecResources struct {
	// Claims corresponds to the JSON schema field "claims".
	Claims []KafkaConnectSpecResourcesClaimsElem `json:"claims,omitempty" yaml:"claims,omitempty" mapstructure:"claims,omitempty"`

	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecResourcesClaimsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Request corresponds to the JSON schema field "request".
	Request *string `json:"request,omitempty" yaml:"request,omitempty" mapstructure:"request,omitempty"`
}

// Template for Kafka Connect and Kafka MirrorMaker 2 resources. The template
// allows users to specify how the `Pods`, `Service`, and other services are
// generated.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplate struct {
	// Template for Kafka Connect API `Service`.
	ApiService *KafkaConnectSpecTemplateApiService `json:"apiService,omitempty" yaml:"apiService,omitempty" mapstructure:"apiService,omitempty"`

	// Template for the Kafka Connect BuildConfig used to build new container images.
	// The BuildConfig is used only on OpenShift.
	BuildConfig *KafkaConnectSpecTemplateBuildConfig `json:"buildConfig,omitempty" yaml:"buildConfig,omitempty" mapstructure:"buildConfig,omitempty"`

	// Template for the Kafka Connect Build container. The build container is used
	// only on Kubernetes.
	BuildContainer *KafkaConnectSpecTemplateBuildContainer `json:"buildContainer,omitempty" yaml:"buildContainer,omitempty" mapstructure:"buildContainer,omitempty"`

	// Template for Kafka Connect Build `Pods`. The build pod is used only on
	// Kubernetes.
	BuildPod *KafkaConnectSpecTemplateBuildPod `json:"buildPod,omitempty" yaml:"buildPod,omitempty" mapstructure:"buildPod,omitempty"`

	// Template for the Kafka Connect Build service account.
	BuildServiceAccount *KafkaConnectSpecTemplateBuildServiceAccount `json:"buildServiceAccount,omitempty" yaml:"buildServiceAccount,omitempty" mapstructure:"buildServiceAccount,omitempty"`

	// Template for the Kafka Connect ClusterRoleBinding.
	ClusterRoleBinding *KafkaConnectSpecTemplateClusterRoleBinding `json:"clusterRoleBinding,omitempty" yaml:"clusterRoleBinding,omitempty" mapstructure:"clusterRoleBinding,omitempty"`

	// Template for the Kafka Connect container.
	ConnectContainer *KafkaConnectSpecTemplateConnectContainer `json:"connectContainer,omitempty" yaml:"connectContainer,omitempty" mapstructure:"connectContainer,omitempty"`

	// Template for Kafka Connect `Deployment`.
	Deployment *KafkaConnectSpecTemplateDeployment `json:"deployment,omitempty" yaml:"deployment,omitempty" mapstructure:"deployment,omitempty"`

	// Template for Kafka Connect headless `Service`.
	HeadlessService *KafkaConnectSpecTemplateHeadlessService `json:"headlessService,omitempty" yaml:"headlessService,omitempty" mapstructure:"headlessService,omitempty"`

	// Template for the Kafka init container.
	InitContainer *KafkaConnectSpecTemplateInitContainer `json:"initContainer,omitempty" yaml:"initContainer,omitempty" mapstructure:"initContainer,omitempty"`

	// Template for Secret of the Kafka Connect Cluster JMX authentication.
	JmxSecret *KafkaConnectSpecTemplateJmxSecret `json:"jmxSecret,omitempty" yaml:"jmxSecret,omitempty" mapstructure:"jmxSecret,omitempty"`

	// Template for Kafka Connect `Pods`.
	Pod *KafkaConnectSpecTemplatePod `json:"pod,omitempty" yaml:"pod,omitempty" mapstructure:"pod,omitempty"`

	// Template for Kafka Connect `PodDisruptionBudget`.
	PodDisruptionBudget *KafkaConnectSpecTemplatePodDisruptionBudget `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty" mapstructure:"podDisruptionBudget,omitempty"`

	// Template for Kafka Connect `StrimziPodSet` resource.
	PodSet *KafkaConnectSpecTemplatePodSet `json:"podSet,omitempty" yaml:"podSet,omitempty" mapstructure:"podSet,omitempty"`

	// Template for the Kafka Connect service account.
	ServiceAccount *KafkaConnectSpecTemplateServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`
}

// Template for Kafka Connect API `Service`.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateApiService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6`. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting.
	IpFamilies []KafkaConnectSpecTemplateApiServiceIpFamiliesElem `json:"ipFamilies,omitempty" yaml:"ipFamilies,omitempty" mapstructure:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type.
	IpFamilyPolicy *KafkaConnectSpecTemplateApiServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty" yaml:"ipFamilyPolicy,omitempty" mapstructure:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateApiServiceMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

type KafkaConnectSpecTemplateApiServiceIpFamiliesElem string

const KafkaConnectSpecTemplateApiServiceIpFamiliesElemIPv4 KafkaConnectSpecTemplateApiServiceIpFamiliesElem = "IPv4"
const KafkaConnectSpecTemplateApiServiceIpFamiliesElemIPv6 KafkaConnectSpecTemplateApiServiceIpFamiliesElem = "IPv6"

var enumValues_KafkaConnectSpecTemplateApiServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateApiServiceIpFamiliesElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateApiServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateApiServiceIpFamiliesElem, v)
	}
	*j = KafkaConnectSpecTemplateApiServiceIpFamiliesElem(v)
	return nil
}

type KafkaConnectSpecTemplateApiServiceIpFamilyPolicy string

const KafkaConnectSpecTemplateApiServiceIpFamilyPolicyPreferDualStack KafkaConnectSpecTemplateApiServiceIpFamilyPolicy = "PreferDualStack"
const KafkaConnectSpecTemplateApiServiceIpFamilyPolicyRequireDualStack KafkaConnectSpecTemplateApiServiceIpFamilyPolicy = "RequireDualStack"
const KafkaConnectSpecTemplateApiServiceIpFamilyPolicySingleStack KafkaConnectSpecTemplateApiServiceIpFamilyPolicy = "SingleStack"

var enumValues_KafkaConnectSpecTemplateApiServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateApiServiceIpFamilyPolicy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateApiServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateApiServiceIpFamilyPolicy, v)
	}
	*j = KafkaConnectSpecTemplateApiServiceIpFamilyPolicy(v)
	return nil
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateApiServiceMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for the Kafka Connect BuildConfig used to build new container images.
// The BuildConfig is used only on OpenShift.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildConfig struct {
	// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
	Metadata *KafkaConnectSpecTemplateBuildConfigMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Container Registry Secret with the credentials for pulling the base image.
	PullSecret *string `json:"pullSecret,omitempty" yaml:"pullSecret,omitempty" mapstructure:"pullSecret,omitempty"`
}

// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildConfigMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for the Kafka Connect Build container. The build container is used only
// on Kubernetes.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaConnectSpecTemplateBuildContainerEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaConnectSpecTemplateBuildContainerSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// Additional volume mounts which should be applied to the container.
	VolumeMounts []KafkaConnectSpecTemplateBuildContainerVolumeMountsElem `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`

	// Reference to the secret or config map property to which the environment
	// variable is set.
	ValueFrom *KafkaConnectSpecTemplateBuildContainerEnvElemValueFrom `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty" mapstructure:"valueFrom,omitempty"`
}

// Reference to the secret or config map property to which the environment variable
// is set.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerEnvElemValueFrom struct {
	// Reference to a key in a config map.
	ConfigMapKeyRef *KafkaConnectSpecTemplateBuildContainerEnvElemValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`

	// Reference to a key in a secret.
	SecretKeyRef *KafkaConnectSpecTemplateBuildContainerEnvElemValueFromSecretKeyRef `json:"secretKeyRef,omitempty" yaml:"secretKeyRef,omitempty" mapstructure:"secretKeyRef,omitempty"`
}

// Reference to a key in a config map.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerEnvElemValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Reference to a key in a secret.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerEnvElemValueFromSecretKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Security context for the container.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// AppArmorProfile corresponds to the JSON schema field "appArmorProfile".
	AppArmorProfile *KafkaConnectSpecTemplateBuildContainerSecurityContextAppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty" mapstructure:"appArmorProfile,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty" yaml:"privileged,omitempty" mapstructure:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty" yaml:"procMount,omitempty" mapstructure:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty" mapstructure:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty" yaml:"windowsOptions,omitempty" mapstructure:"windowsOptions,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerSecurityContextAppArmorProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty" yaml:"add,omitempty" mapstructure:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty" yaml:"gmsaCredentialSpec,omitempty" mapstructure:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty" yaml:"gmsaCredentialSpecName,omitempty" mapstructure:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty" yaml:"hostProcess,omitempty" mapstructure:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty" yaml:"runAsUserName,omitempty" mapstructure:"runAsUserName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildContainerVolumeMountsElem struct {
	// MountPath corresponds to the JSON schema field "mountPath".
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// MountPropagation corresponds to the JSON schema field "mountPropagation".
	MountPropagation *string `json:"mountPropagation,omitempty" yaml:"mountPropagation,omitempty" mapstructure:"mountPropagation,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// RecursiveReadOnly corresponds to the JSON schema field "recursiveReadOnly".
	RecursiveReadOnly *string `json:"recursiveReadOnly,omitempty" yaml:"recursiveReadOnly,omitempty" mapstructure:"recursiveReadOnly,omitempty"`

	// SubPath corresponds to the JSON schema field "subPath".
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// SubPathExpr corresponds to the JSON schema field "subPathExpr".
	SubPathExpr *string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}

// Template for Kafka Connect Build `Pods`. The build pod is used only on
// Kubernetes.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPod struct {
	// The pod's affinity rules.
	Affinity *KafkaConnectSpecTemplateBuildPodAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// The pod's DNSConfig. If specified, it will be merged to the generated DNS
	// configuration based on the DNSPolicy.
	DnsConfig *KafkaConnectSpecTemplateBuildPodDnsConfig `json:"dnsConfig,omitempty" yaml:"dnsConfig,omitempty" mapstructure:"dnsConfig,omitempty"`

	// The pod's DNSPolicy. Defaults to `ClusterFirst`. Valid values are
	// `ClusterFirstWithHostNet`, `ClusterFirst`, `Default` or `None`.
	DnsPolicy *KafkaConnectSpecTemplateBuildPodDnsPolicy `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty" mapstructure:"dnsPolicy,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaConnectSpecTemplateBuildPodHostAliasesElem `json:"hostAliases,omitempty" yaml:"hostAliases,omitempty" mapstructure:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaConnectSpecTemplateBuildPodImagePullSecretsElem `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateBuildPodMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaConnectSpecTemplateBuildPodSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty" mapstructure:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount of pod memory allocated for the temporary `EmptyDir`
	// volume `/tmp`. Specify the allocation in memory units, for example, `100Mi` for
	// 100 mebibytes. Default value is `5Mi`. The `/tmp` volume is backed by pod
	// memory, not disk storage, so avoid setting a high value as it consumes pod
	// memory resources.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty" yaml:"tmpDirSizeLimit,omitempty" mapstructure:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaConnectSpecTemplateBuildPodTolerationsElem `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`

	// Additional volumes that can be mounted to the pod.
	Volumes []KafkaConnectSpecTemplateBuildPodVolumesElem `json:"volumes,omitempty" yaml:"volumes,omitempty" mapstructure:"volumes,omitempty"`
}

// The pod's affinity rules.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity `json:"nodeAffinity,omitempty" yaml:"nodeAffinity,omitempty" mapstructure:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaConnectSpecTemplateBuildPodAffinityPodAffinity `json:"podAffinity,omitempty" yaml:"podAffinity,omitempty" mapstructure:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty" yaml:"podAntiAffinity,omitempty" mapstructure:"podAntiAffinity,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty" yaml:"preference,omitempty" mapstructure:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty" yaml:"matchFields,omitempty" mapstructure:"matchFields,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty" yaml:"nodeSelectorTerms,omitempty" mapstructure:"nodeSelectorTerms,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty" yaml:"matchFields,omitempty" mapstructure:"matchFields,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty" yaml:"podAffinityTerm,omitempty" mapstructure:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty" yaml:"podAffinityTerm,omitempty" mapstructure:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// The pod's DNSConfig. If specified, it will be merged to the generated DNS
// configuration based on the DNSPolicy.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodDnsConfig struct {
	// Nameservers corresponds to the JSON schema field "nameservers".
	Nameservers []string `json:"nameservers,omitempty" yaml:"nameservers,omitempty" mapstructure:"nameservers,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options []KafkaConnectSpecTemplateBuildPodDnsConfigOptionsElem `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Searches corresponds to the JSON schema field "searches".
	Searches []string `json:"searches,omitempty" yaml:"searches,omitempty" mapstructure:"searches,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodDnsConfigOptionsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type KafkaConnectSpecTemplateBuildPodDnsPolicy string

const KafkaConnectSpecTemplateBuildPodDnsPolicyClusterFirst KafkaConnectSpecTemplateBuildPodDnsPolicy = "ClusterFirst"
const KafkaConnectSpecTemplateBuildPodDnsPolicyClusterFirstWithHostNet KafkaConnectSpecTemplateBuildPodDnsPolicy = "ClusterFirstWithHostNet"
const KafkaConnectSpecTemplateBuildPodDnsPolicyDefault KafkaConnectSpecTemplateBuildPodDnsPolicy = "Default"
const KafkaConnectSpecTemplateBuildPodDnsPolicyNone KafkaConnectSpecTemplateBuildPodDnsPolicy = "None"

var enumValues_KafkaConnectSpecTemplateBuildPodDnsPolicy = []interface{}{
	"ClusterFirst",
	"ClusterFirstWithHostNet",
	"Default",
	"None",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateBuildPodDnsPolicy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateBuildPodDnsPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateBuildPodDnsPolicy, v)
	}
	*j = KafkaConnectSpecTemplateBuildPodDnsPolicy(v)
	return nil
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty" yaml:"hostnames,omitempty" mapstructure:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty" yaml:"ip,omitempty" mapstructure:"ip,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Configures pod-level security attributes and common container settings.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodSecurityContext struct {
	// AppArmorProfile corresponds to the JSON schema field "appArmorProfile".
	AppArmorProfile *KafkaConnectSpecTemplateBuildPodSecurityContextAppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty" mapstructure:"appArmorProfile,omitempty"`

	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeLinuxChangePolicy corresponds to the JSON schema field "seLinuxChangePolicy".
	SeLinuxChangePolicy *string `json:"seLinuxChangePolicy,omitempty" yaml:"seLinuxChangePolicy,omitempty" mapstructure:"seLinuxChangePolicy,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty" mapstructure:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// SupplementalGroupsPolicy corresponds to the JSON schema field
	// "supplementalGroupsPolicy".
	SupplementalGroupsPolicy *string `json:"supplementalGroupsPolicy,omitempty" yaml:"supplementalGroupsPolicy,omitempty" mapstructure:"supplementalGroupsPolicy,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaConnectSpecTemplateBuildPodSecurityContextSysctlsElem `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions `json:"windowsOptions,omitempty" yaml:"windowsOptions,omitempty" mapstructure:"windowsOptions,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodSecurityContextAppArmorProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty" yaml:"gmsaCredentialSpec,omitempty" mapstructure:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty" yaml:"gmsaCredentialSpecName,omitempty" mapstructure:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty" yaml:"hostProcess,omitempty" mapstructure:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty" yaml:"runAsUserName,omitempty" mapstructure:"runAsUserName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty" yaml:"effect,omitempty" mapstructure:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty" yaml:"tolerationSeconds,omitempty" mapstructure:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty" yaml:"maxSkew,omitempty" mapstructure:"maxSkew,omitempty"`

	// MinDomains corresponds to the JSON schema field "minDomains".
	MinDomains *int32 `json:"minDomains,omitempty" yaml:"minDomains,omitempty" mapstructure:"minDomains,omitempty"`

	// NodeAffinityPolicy corresponds to the JSON schema field "nodeAffinityPolicy".
	NodeAffinityPolicy *string `json:"nodeAffinityPolicy,omitempty" yaml:"nodeAffinityPolicy,omitempty" mapstructure:"nodeAffinityPolicy,omitempty"`

	// NodeTaintsPolicy corresponds to the JSON schema field "nodeTaintsPolicy".
	NodeTaintsPolicy *string `json:"nodeTaintsPolicy,omitempty" yaml:"nodeTaintsPolicy,omitempty" mapstructure:"nodeTaintsPolicy,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty" yaml:"whenUnsatisfiable,omitempty" mapstructure:"whenUnsatisfiable,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElem struct {
	// `ConfigMap` to use to populate the volume.
	ConfigMap *KafkaConnectSpecTemplateBuildPodVolumesElemConfigMap `json:"configMap,omitempty" yaml:"configMap,omitempty" mapstructure:"configMap,omitempty"`

	// `CSIVolumeSource` object to use to populate the volume.
	Csi *KafkaConnectSpecTemplateBuildPodVolumesElemCsi `json:"csi,omitempty" yaml:"csi,omitempty" mapstructure:"csi,omitempty"`

	// `EmptyDir` to use to populate the volume.
	EmptyDir *KafkaConnectSpecTemplateBuildPodVolumesElemEmptyDir `json:"emptyDir,omitempty" yaml:"emptyDir,omitempty" mapstructure:"emptyDir,omitempty"`

	// `ImageVolumeSource` object to use to populate the volume.
	Image *KafkaConnectSpecTemplateBuildPodVolumesElemImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Name to use for the volume. Required.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// `PersistentVolumeClaim` object to use to populate the volume.
	PersistentVolumeClaim *KafkaConnectSpecTemplateBuildPodVolumesElemPersistentVolumeClaim `json:"persistentVolumeClaim,omitempty" yaml:"persistentVolumeClaim,omitempty" mapstructure:"persistentVolumeClaim,omitempty"`

	// `Secret` to use to populate the volume.
	Secret *KafkaConnectSpecTemplateBuildPodVolumesElemSecret `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`
}

// `ConfigMap` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemConfigMap struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty" yaml:"defaultMode,omitempty" mapstructure:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaConnectSpecTemplateBuildPodVolumesElemConfigMapItemsElem `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemConfigMapItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

// `CSIVolumeSource` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemCsi struct {
	// Driver corresponds to the JSON schema field "driver".
	Driver *string `json:"driver,omitempty" yaml:"driver,omitempty" mapstructure:"driver,omitempty"`

	// FsType corresponds to the JSON schema field "fsType".
	FsType *string `json:"fsType,omitempty" yaml:"fsType,omitempty" mapstructure:"fsType,omitempty"`

	// NodePublishSecretRef corresponds to the JSON schema field
	// "nodePublishSecretRef".
	NodePublishSecretRef *KafkaConnectSpecTemplateBuildPodVolumesElemCsiNodePublishSecretRef `json:"nodePublishSecretRef,omitempty" yaml:"nodePublishSecretRef,omitempty" mapstructure:"nodePublishSecretRef,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// VolumeAttributes corresponds to the JSON schema field "volumeAttributes".
	VolumeAttributes map[string]string `json:"volumeAttributes,omitempty" yaml:"volumeAttributes,omitempty" mapstructure:"volumeAttributes,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemCsiNodePublishSecretRef struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// `EmptyDir` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemEmptyDir struct {
	// Medium corresponds to the JSON schema field "medium".
	Medium *string `json:"medium,omitempty" yaml:"medium,omitempty" mapstructure:"medium,omitempty"`

	// SizeLimit corresponds to the JSON schema field "sizeLimit".
	SizeLimit *KafkaConnectSpecTemplateBuildPodVolumesElemEmptyDirSizeLimit `json:"sizeLimit,omitempty" yaml:"sizeLimit,omitempty" mapstructure:"sizeLimit,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemEmptyDirSizeLimit struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount *string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Format corresponds to the JSON schema field "format".
	Format *string `json:"format,omitempty" yaml:"format,omitempty" mapstructure:"format,omitempty"`
}

// `ImageVolumeSource` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemImage struct {
	// PullPolicy corresponds to the JSON schema field "pullPolicy".
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Reference corresponds to the JSON schema field "reference".
	Reference *string `json:"reference,omitempty" yaml:"reference,omitempty" mapstructure:"reference,omitempty"`
}

// `PersistentVolumeClaim` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemPersistentVolumeClaim struct {
	// ClaimName corresponds to the JSON schema field "claimName".
	ClaimName *string `json:"claimName,omitempty" yaml:"claimName,omitempty" mapstructure:"claimName,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`
}

// `Secret` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemSecret struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty" yaml:"defaultMode,omitempty" mapstructure:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaConnectSpecTemplateBuildPodVolumesElemSecretItemsElem `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// SecretName corresponds to the JSON schema field "secretName".
	SecretName *string `json:"secretName,omitempty" yaml:"secretName,omitempty" mapstructure:"secretName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildPodVolumesElemSecretItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateBuildPod) UnmarshalJSON(value []byte) error {
	type Plain KafkaConnectSpecTemplateBuildPod
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TerminationGracePeriodSeconds != nil && 0 > *plain.TerminationGracePeriodSeconds {
		return fmt.Errorf("field %s: must be >= %v", "terminationGracePeriodSeconds", 0)
	}
	if plain.TmpDirSizeLimit != nil {
		if matched, _ := regexp.MatchString(`^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$`, string(*plain.TmpDirSizeLimit)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TmpDirSizeLimit", `^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$`)
		}
	}
	*j = KafkaConnectSpecTemplateBuildPod(plain)
	return nil
}

// Template for the Kafka Connect Build service account.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateBuildServiceAccountMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateBuildServiceAccountMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for the Kafka Connect ClusterRoleBinding.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateClusterRoleBinding struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateClusterRoleBindingMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateClusterRoleBindingMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for the Kafka Connect container.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaConnectSpecTemplateConnectContainerEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaConnectSpecTemplateConnectContainerSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// Additional volume mounts which should be applied to the container.
	VolumeMounts []KafkaConnectSpecTemplateConnectContainerVolumeMountsElem `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`

	// Reference to the secret or config map property to which the environment
	// variable is set.
	ValueFrom *KafkaConnectSpecTemplateConnectContainerEnvElemValueFrom `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty" mapstructure:"valueFrom,omitempty"`
}

// Reference to the secret or config map property to which the environment variable
// is set.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerEnvElemValueFrom struct {
	// Reference to a key in a config map.
	ConfigMapKeyRef *KafkaConnectSpecTemplateConnectContainerEnvElemValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`

	// Reference to a key in a secret.
	SecretKeyRef *KafkaConnectSpecTemplateConnectContainerEnvElemValueFromSecretKeyRef `json:"secretKeyRef,omitempty" yaml:"secretKeyRef,omitempty" mapstructure:"secretKeyRef,omitempty"`
}

// Reference to a key in a config map.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerEnvElemValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Reference to a key in a secret.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerEnvElemValueFromSecretKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Security context for the container.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// AppArmorProfile corresponds to the JSON schema field "appArmorProfile".
	AppArmorProfile *KafkaConnectSpecTemplateConnectContainerSecurityContextAppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty" mapstructure:"appArmorProfile,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty" yaml:"privileged,omitempty" mapstructure:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty" yaml:"procMount,omitempty" mapstructure:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty" mapstructure:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty" yaml:"windowsOptions,omitempty" mapstructure:"windowsOptions,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerSecurityContextAppArmorProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty" yaml:"add,omitempty" mapstructure:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty" yaml:"gmsaCredentialSpec,omitempty" mapstructure:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty" yaml:"gmsaCredentialSpecName,omitempty" mapstructure:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty" yaml:"hostProcess,omitempty" mapstructure:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty" yaml:"runAsUserName,omitempty" mapstructure:"runAsUserName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateConnectContainerVolumeMountsElem struct {
	// MountPath corresponds to the JSON schema field "mountPath".
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// MountPropagation corresponds to the JSON schema field "mountPropagation".
	MountPropagation *string `json:"mountPropagation,omitempty" yaml:"mountPropagation,omitempty" mapstructure:"mountPropagation,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// RecursiveReadOnly corresponds to the JSON schema field "recursiveReadOnly".
	RecursiveReadOnly *string `json:"recursiveReadOnly,omitempty" yaml:"recursiveReadOnly,omitempty" mapstructure:"recursiveReadOnly,omitempty"`

	// SubPath corresponds to the JSON schema field "subPath".
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// SubPathExpr corresponds to the JSON schema field "subPathExpr".
	SubPathExpr *string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}

// Template for Kafka Connect `Deployment`.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateDeployment struct {
	// Pod replacement strategy for deployment configuration changes. Valid values are
	// `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
	DeploymentStrategy *KafkaConnectSpecTemplateDeploymentDeploymentStrategy `json:"deploymentStrategy,omitempty" yaml:"deploymentStrategy,omitempty" mapstructure:"deploymentStrategy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateDeploymentMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

type KafkaConnectSpecTemplateDeploymentDeploymentStrategy string

const KafkaConnectSpecTemplateDeploymentDeploymentStrategyRecreate KafkaConnectSpecTemplateDeploymentDeploymentStrategy = "Recreate"
const KafkaConnectSpecTemplateDeploymentDeploymentStrategyRollingUpdate KafkaConnectSpecTemplateDeploymentDeploymentStrategy = "RollingUpdate"

var enumValues_KafkaConnectSpecTemplateDeploymentDeploymentStrategy = []interface{}{
	"RollingUpdate",
	"Recreate",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateDeploymentDeploymentStrategy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateDeploymentDeploymentStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateDeploymentDeploymentStrategy, v)
	}
	*j = KafkaConnectSpecTemplateDeploymentDeploymentStrategy(v)
	return nil
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateDeploymentMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for Kafka Connect headless `Service`.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateHeadlessService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6`. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting.
	IpFamilies []KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem `json:"ipFamilies,omitempty" yaml:"ipFamilies,omitempty" mapstructure:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type.
	IpFamilyPolicy *KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty" yaml:"ipFamilyPolicy,omitempty" mapstructure:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateHeadlessServiceMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

type KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem string

const KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElemIPv4 KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem = "IPv4"
const KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElemIPv6 KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem = "IPv6"

var enumValues_KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem, v)
	}
	*j = KafkaConnectSpecTemplateHeadlessServiceIpFamiliesElem(v)
	return nil
}

type KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy string

const KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicyPreferDualStack KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy = "PreferDualStack"
const KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicyRequireDualStack KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy = "RequireDualStack"
const KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicySingleStack KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy = "SingleStack"

var enumValues_KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy, v)
	}
	*j = KafkaConnectSpecTemplateHeadlessServiceIpFamilyPolicy(v)
	return nil
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateHeadlessServiceMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for the Kafka init container.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaConnectSpecTemplateInitContainerEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaConnectSpecTemplateInitContainerSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// Additional volume mounts which should be applied to the container.
	VolumeMounts []KafkaConnectSpecTemplateInitContainerVolumeMountsElem `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`

	// Reference to the secret or config map property to which the environment
	// variable is set.
	ValueFrom *KafkaConnectSpecTemplateInitContainerEnvElemValueFrom `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty" mapstructure:"valueFrom,omitempty"`
}

// Reference to the secret or config map property to which the environment variable
// is set.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerEnvElemValueFrom struct {
	// Reference to a key in a config map.
	ConfigMapKeyRef *KafkaConnectSpecTemplateInitContainerEnvElemValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`

	// Reference to a key in a secret.
	SecretKeyRef *KafkaConnectSpecTemplateInitContainerEnvElemValueFromSecretKeyRef `json:"secretKeyRef,omitempty" yaml:"secretKeyRef,omitempty" mapstructure:"secretKeyRef,omitempty"`
}

// Reference to a key in a config map.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerEnvElemValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Reference to a key in a secret.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerEnvElemValueFromSecretKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Security context for the container.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// AppArmorProfile corresponds to the JSON schema field "appArmorProfile".
	AppArmorProfile *KafkaConnectSpecTemplateInitContainerSecurityContextAppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty" mapstructure:"appArmorProfile,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty" yaml:"privileged,omitempty" mapstructure:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty" yaml:"procMount,omitempty" mapstructure:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty" mapstructure:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty" yaml:"windowsOptions,omitempty" mapstructure:"windowsOptions,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerSecurityContextAppArmorProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty" yaml:"add,omitempty" mapstructure:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty" yaml:"gmsaCredentialSpec,omitempty" mapstructure:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty" yaml:"gmsaCredentialSpecName,omitempty" mapstructure:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty" yaml:"hostProcess,omitempty" mapstructure:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty" yaml:"runAsUserName,omitempty" mapstructure:"runAsUserName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateInitContainerVolumeMountsElem struct {
	// MountPath corresponds to the JSON schema field "mountPath".
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// MountPropagation corresponds to the JSON schema field "mountPropagation".
	MountPropagation *string `json:"mountPropagation,omitempty" yaml:"mountPropagation,omitempty" mapstructure:"mountPropagation,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// RecursiveReadOnly corresponds to the JSON schema field "recursiveReadOnly".
	RecursiveReadOnly *string `json:"recursiveReadOnly,omitempty" yaml:"recursiveReadOnly,omitempty" mapstructure:"recursiveReadOnly,omitempty"`

	// SubPath corresponds to the JSON schema field "subPath".
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// SubPathExpr corresponds to the JSON schema field "subPathExpr".
	SubPathExpr *string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}

// Template for Secret of the Kafka Connect Cluster JMX authentication.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateJmxSecret struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateJmxSecretMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateJmxSecretMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for Kafka Connect `Pods`.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaConnectSpecTemplatePodAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// The pod's DNSConfig. If specified, it will be merged to the generated DNS
	// configuration based on the DNSPolicy.
	DnsConfig *KafkaConnectSpecTemplatePodDnsConfig `json:"dnsConfig,omitempty" yaml:"dnsConfig,omitempty" mapstructure:"dnsConfig,omitempty"`

	// The pod's DNSPolicy. Defaults to `ClusterFirst`. Valid values are
	// `ClusterFirstWithHostNet`, `ClusterFirst`, `Default` or `None`.
	DnsPolicy *KafkaConnectSpecTemplatePodDnsPolicy `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty" mapstructure:"dnsPolicy,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaConnectSpecTemplatePodHostAliasesElem `json:"hostAliases,omitempty" yaml:"hostAliases,omitempty" mapstructure:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaConnectSpecTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplatePodMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaConnectSpecTemplatePodSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty" mapstructure:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount of pod memory allocated for the temporary `EmptyDir`
	// volume `/tmp`. Specify the allocation in memory units, for example, `100Mi` for
	// 100 mebibytes. Default value is `5Mi`. The `/tmp` volume is backed by pod
	// memory, not disk storage, so avoid setting a high value as it consumes pod
	// memory resources.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty" yaml:"tmpDirSizeLimit,omitempty" mapstructure:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaConnectSpecTemplatePodTolerationsElem `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaConnectSpecTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`

	// Additional volumes that can be mounted to the pod.
	Volumes []KafkaConnectSpecTemplatePodVolumesElem `json:"volumes,omitempty" yaml:"volumes,omitempty" mapstructure:"volumes,omitempty"`
}

// The pod's affinity rules.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaConnectSpecTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty" yaml:"nodeAffinity,omitempty" mapstructure:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaConnectSpecTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty" yaml:"podAffinity,omitempty" mapstructure:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaConnectSpecTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty" yaml:"podAntiAffinity,omitempty" mapstructure:"podAntiAffinity,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty" yaml:"preference,omitempty" mapstructure:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty" yaml:"matchFields,omitempty" mapstructure:"matchFields,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty" yaml:"nodeSelectorTerms,omitempty" mapstructure:"nodeSelectorTerms,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty" yaml:"matchFields,omitempty" mapstructure:"matchFields,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty" yaml:"podAffinityTerm,omitempty" mapstructure:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty" yaml:"podAffinityTerm,omitempty" mapstructure:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// Template for Kafka Connect `PodDisruptionBudget`.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodDisruptionBudget struct {
	// Maximum number of unavailable pods to allow automatic Pod eviction. A Pod
	// eviction is allowed when the `maxUnavailable` number of pods or fewer are
	// unavailable after the eviction. Setting this value to 0 prevents all voluntary
	// evictions, so the pods must be evicted manually. Defaults to 1.
	MaxUnavailable *int32 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty" mapstructure:"maxUnavailable,omitempty"`

	// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
	Metadata *KafkaConnectSpecTemplatePodDisruptionBudgetMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodDisruptionBudgetMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplatePodDisruptionBudget) UnmarshalJSON(value []byte) error {
	type Plain KafkaConnectSpecTemplatePodDisruptionBudget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MaxUnavailable != nil && 0 > *plain.MaxUnavailable {
		return fmt.Errorf("field %s: must be >= %v", "maxUnavailable", 0)
	}
	*j = KafkaConnectSpecTemplatePodDisruptionBudget(plain)
	return nil
}

// The pod's DNSConfig. If specified, it will be merged to the generated DNS
// configuration based on the DNSPolicy.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodDnsConfig struct {
	// Nameservers corresponds to the JSON schema field "nameservers".
	Nameservers []string `json:"nameservers,omitempty" yaml:"nameservers,omitempty" mapstructure:"nameservers,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options []KafkaConnectSpecTemplatePodDnsConfigOptionsElem `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Searches corresponds to the JSON schema field "searches".
	Searches []string `json:"searches,omitempty" yaml:"searches,omitempty" mapstructure:"searches,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodDnsConfigOptionsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type KafkaConnectSpecTemplatePodDnsPolicy string

const KafkaConnectSpecTemplatePodDnsPolicyClusterFirst KafkaConnectSpecTemplatePodDnsPolicy = "ClusterFirst"
const KafkaConnectSpecTemplatePodDnsPolicyClusterFirstWithHostNet KafkaConnectSpecTemplatePodDnsPolicy = "ClusterFirstWithHostNet"
const KafkaConnectSpecTemplatePodDnsPolicyDefault KafkaConnectSpecTemplatePodDnsPolicy = "Default"
const KafkaConnectSpecTemplatePodDnsPolicyNone KafkaConnectSpecTemplatePodDnsPolicy = "None"

var enumValues_KafkaConnectSpecTemplatePodDnsPolicy = []interface{}{
	"ClusterFirst",
	"ClusterFirstWithHostNet",
	"Default",
	"None",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplatePodDnsPolicy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTemplatePodDnsPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTemplatePodDnsPolicy, v)
	}
	*j = KafkaConnectSpecTemplatePodDnsPolicy(v)
	return nil
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty" yaml:"hostnames,omitempty" mapstructure:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty" yaml:"ip,omitempty" mapstructure:"ip,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Configures pod-level security attributes and common container settings.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodSecurityContext struct {
	// AppArmorProfile corresponds to the JSON schema field "appArmorProfile".
	AppArmorProfile *KafkaConnectSpecTemplatePodSecurityContextAppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty" mapstructure:"appArmorProfile,omitempty"`

	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeLinuxChangePolicy corresponds to the JSON schema field "seLinuxChangePolicy".
	SeLinuxChangePolicy *string `json:"seLinuxChangePolicy,omitempty" yaml:"seLinuxChangePolicy,omitempty" mapstructure:"seLinuxChangePolicy,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty" mapstructure:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaConnectSpecTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// SupplementalGroupsPolicy corresponds to the JSON schema field
	// "supplementalGroupsPolicy".
	SupplementalGroupsPolicy *string `json:"supplementalGroupsPolicy,omitempty" yaml:"supplementalGroupsPolicy,omitempty" mapstructure:"supplementalGroupsPolicy,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaConnectSpecTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaConnectSpecTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty" yaml:"windowsOptions,omitempty" mapstructure:"windowsOptions,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodSecurityContextAppArmorProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty" yaml:"gmsaCredentialSpec,omitempty" mapstructure:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty" yaml:"gmsaCredentialSpecName,omitempty" mapstructure:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty" yaml:"hostProcess,omitempty" mapstructure:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty" yaml:"runAsUserName,omitempty" mapstructure:"runAsUserName,omitempty"`
}

// Template for Kafka Connect `StrimziPodSet` resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodSet struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplatePodSetMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodSetMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty" yaml:"effect,omitempty" mapstructure:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty" yaml:"tolerationSeconds,omitempty" mapstructure:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty" yaml:"maxSkew,omitempty" mapstructure:"maxSkew,omitempty"`

	// MinDomains corresponds to the JSON schema field "minDomains".
	MinDomains *int32 `json:"minDomains,omitempty" yaml:"minDomains,omitempty" mapstructure:"minDomains,omitempty"`

	// NodeAffinityPolicy corresponds to the JSON schema field "nodeAffinityPolicy".
	NodeAffinityPolicy *string `json:"nodeAffinityPolicy,omitempty" yaml:"nodeAffinityPolicy,omitempty" mapstructure:"nodeAffinityPolicy,omitempty"`

	// NodeTaintsPolicy corresponds to the JSON schema field "nodeTaintsPolicy".
	NodeTaintsPolicy *string `json:"nodeTaintsPolicy,omitempty" yaml:"nodeTaintsPolicy,omitempty" mapstructure:"nodeTaintsPolicy,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty" yaml:"whenUnsatisfiable,omitempty" mapstructure:"whenUnsatisfiable,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElem struct {
	// `ConfigMap` to use to populate the volume.
	ConfigMap *KafkaConnectSpecTemplatePodVolumesElemConfigMap `json:"configMap,omitempty" yaml:"configMap,omitempty" mapstructure:"configMap,omitempty"`

	// `CSIVolumeSource` object to use to populate the volume.
	Csi *KafkaConnectSpecTemplatePodVolumesElemCsi `json:"csi,omitempty" yaml:"csi,omitempty" mapstructure:"csi,omitempty"`

	// `EmptyDir` to use to populate the volume.
	EmptyDir *KafkaConnectSpecTemplatePodVolumesElemEmptyDir `json:"emptyDir,omitempty" yaml:"emptyDir,omitempty" mapstructure:"emptyDir,omitempty"`

	// `ImageVolumeSource` object to use to populate the volume.
	Image *KafkaConnectSpecTemplatePodVolumesElemImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Name to use for the volume. Required.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// `PersistentVolumeClaim` object to use to populate the volume.
	PersistentVolumeClaim *KafkaConnectSpecTemplatePodVolumesElemPersistentVolumeClaim `json:"persistentVolumeClaim,omitempty" yaml:"persistentVolumeClaim,omitempty" mapstructure:"persistentVolumeClaim,omitempty"`

	// `Secret` to use to populate the volume.
	Secret *KafkaConnectSpecTemplatePodVolumesElemSecret `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`
}

// `ConfigMap` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemConfigMap struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty" yaml:"defaultMode,omitempty" mapstructure:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaConnectSpecTemplatePodVolumesElemConfigMapItemsElem `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemConfigMapItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

// `CSIVolumeSource` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemCsi struct {
	// Driver corresponds to the JSON schema field "driver".
	Driver *string `json:"driver,omitempty" yaml:"driver,omitempty" mapstructure:"driver,omitempty"`

	// FsType corresponds to the JSON schema field "fsType".
	FsType *string `json:"fsType,omitempty" yaml:"fsType,omitempty" mapstructure:"fsType,omitempty"`

	// NodePublishSecretRef corresponds to the JSON schema field
	// "nodePublishSecretRef".
	NodePublishSecretRef *KafkaConnectSpecTemplatePodVolumesElemCsiNodePublishSecretRef `json:"nodePublishSecretRef,omitempty" yaml:"nodePublishSecretRef,omitempty" mapstructure:"nodePublishSecretRef,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// VolumeAttributes corresponds to the JSON schema field "volumeAttributes".
	VolumeAttributes map[string]string `json:"volumeAttributes,omitempty" yaml:"volumeAttributes,omitempty" mapstructure:"volumeAttributes,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemCsiNodePublishSecretRef struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// `EmptyDir` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemEmptyDir struct {
	// Medium corresponds to the JSON schema field "medium".
	Medium *string `json:"medium,omitempty" yaml:"medium,omitempty" mapstructure:"medium,omitempty"`

	// SizeLimit corresponds to the JSON schema field "sizeLimit".
	SizeLimit *KafkaConnectSpecTemplatePodVolumesElemEmptyDirSizeLimit `json:"sizeLimit,omitempty" yaml:"sizeLimit,omitempty" mapstructure:"sizeLimit,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemEmptyDirSizeLimit struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount *string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Format corresponds to the JSON schema field "format".
	Format *string `json:"format,omitempty" yaml:"format,omitempty" mapstructure:"format,omitempty"`
}

// `ImageVolumeSource` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemImage struct {
	// PullPolicy corresponds to the JSON schema field "pullPolicy".
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Reference corresponds to the JSON schema field "reference".
	Reference *string `json:"reference,omitempty" yaml:"reference,omitempty" mapstructure:"reference,omitempty"`
}

// `PersistentVolumeClaim` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemPersistentVolumeClaim struct {
	// ClaimName corresponds to the JSON schema field "claimName".
	ClaimName *string `json:"claimName,omitempty" yaml:"claimName,omitempty" mapstructure:"claimName,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`
}

// `Secret` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemSecret struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty" yaml:"defaultMode,omitempty" mapstructure:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaConnectSpecTemplatePodVolumesElemSecretItemsElem `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// SecretName corresponds to the JSON schema field "secretName".
	SecretName *string `json:"secretName,omitempty" yaml:"secretName,omitempty" mapstructure:"secretName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplatePodVolumesElemSecretItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTemplatePod) UnmarshalJSON(value []byte) error {
	type Plain KafkaConnectSpecTemplatePod
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TerminationGracePeriodSeconds != nil && 0 > *plain.TerminationGracePeriodSeconds {
		return fmt.Errorf("field %s: must be >= %v", "terminationGracePeriodSeconds", 0)
	}
	if plain.TmpDirSizeLimit != nil {
		if matched, _ := regexp.MatchString(`^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$`, string(*plain.TmpDirSizeLimit)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TmpDirSizeLimit", `^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$`)
		}
	}
	*j = KafkaConnectSpecTemplatePod(plain)
	return nil
}

// Template for the Kafka Connect service account.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaConnectSpecTemplateServiceAccountMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTemplateServiceAccountMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// TLS configuration.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTls struct {
	// Trusted certificates for TLS connection.
	TrustedCertificates []KafkaConnectSpecTlsTrustedCertificatesElem `json:"trustedCertificates,omitempty" yaml:"trustedCertificates,omitempty" mapstructure:"trustedCertificates,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectSpecTlsTrustedCertificatesElem struct {
	// The name of the file certificate in the secret.
	Certificate *string `json:"certificate,omitempty" yaml:"certificate,omitempty" mapstructure:"certificate,omitempty"`

	// Pattern for the certificate files in the secret. Use the
	// link:https://en.wikipedia.org/wiki/Glob_(programming)[_glob syntax_] for the
	// pattern. All files in the secret that match the pattern are used.
	Pattern *string `json:"pattern,omitempty" yaml:"pattern,omitempty" mapstructure:"pattern,omitempty"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTlsTrustedCertificatesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaConnectSpecTlsTrustedCertificatesElem: required")
	}
	type Plain KafkaConnectSpecTlsTrustedCertificatesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecTlsTrustedCertificatesElem(plain)
	return nil
}

// The configuration of tracing in Kafka Connect.
// +kubebuilder:object:generate=true
type KafkaConnectSpecTracing struct {
	// Type of the tracing used. Currently the only supported type is `opentelemetry`
	// for OpenTelemetry tracing. As of Strimzi 0.37.0, `jaeger` type is not supported
	// anymore and this option is ignored.
	Type KafkaConnectSpecTracingType `json:"type" yaml:"type" mapstructure:"type"`
}

type KafkaConnectSpecTracingType string

const KafkaConnectSpecTracingTypeJaeger KafkaConnectSpecTracingType = "jaeger"
const KafkaConnectSpecTracingTypeOpentelemetry KafkaConnectSpecTracingType = "opentelemetry"

var enumValues_KafkaConnectSpecTracingType = []interface{}{
	"jaeger",
	"opentelemetry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTracingType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaConnectSpecTracingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaConnectSpecTracingType, v)
	}
	*j = KafkaConnectSpecTracingType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpecTracing) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaConnectSpecTracing: required")
	}
	type Plain KafkaConnectSpecTracing
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpecTracing(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaConnectSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bootstrapServers"]; raw != nil && !ok {
		return fmt.Errorf("field bootstrapServers in KafkaConnectSpec: required")
	}
	type Plain KafkaConnectSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaConnectSpec(plain)
	return nil
}

// The status of the Kafka Connect cluster.
// +kubebuilder:object:generate=true
type KafkaConnectStatus struct {
	// List of status conditions.
	Conditions []KafkaConnectStatusConditionsElem `json:"conditions,omitempty" yaml:"conditions,omitempty" mapstructure:"conditions,omitempty"`

	// The list of connector plugins available in this Kafka Connect deployment.
	ConnectorPlugins []KafkaConnectStatusConnectorPluginsElem `json:"connectorPlugins,omitempty" yaml:"connectorPlugins,omitempty" mapstructure:"connectorPlugins,omitempty"`

	// Label selector for pods providing this resource.
	LabelSelector *string `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// The generation of the CRD that was last reconciled by the operator.
	ObservedGeneration *int32 `json:"observedGeneration,omitempty" yaml:"observedGeneration,omitempty" mapstructure:"observedGeneration,omitempty"`

	// The current number of pods being used to provide this resource.
	Replicas *int32 `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// The URL of the REST API endpoint for managing and monitoring Kafka Connect
	// connectors.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectStatusConditionsElem struct {
	// Last time the condition of a type changed from one status to another. The
	// required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
	LastTransitionTime *string `json:"lastTransitionTime,omitempty" yaml:"lastTransitionTime,omitempty" mapstructure:"lastTransitionTime,omitempty"`

	// Human-readable message indicating details about the condition's last
	// transition.
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// The reason for the condition's last transition (a single word in CamelCase).
	Reason *string `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// The status of the condition, either True, False or Unknown.
	Status *string `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`

	// The unique identifier of a condition, used to distinguish between other
	// conditions in the resource.
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaConnectStatusConnectorPluginsElem struct {
	// The class of the connector plugin.
	Class *string `json:"class,omitempty" yaml:"class,omitempty" mapstructure:"class,omitempty"`

	// The type of the connector plugin. The available types are `sink` and `source`.
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// The version of the connector plugin.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}
