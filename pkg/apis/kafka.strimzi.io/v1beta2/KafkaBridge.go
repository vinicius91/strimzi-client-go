// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1beta2

import (
	"encoding/json"
	"fmt"
	"reflect"
	"regexp"

	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// KafkaBridge
type KafkaBridge struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// The specification of the Kafka Bridge.
	Spec *KafkaBridgeSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`

	// The status of the Kafka Bridge.
	Status *KafkaBridgeStatus `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`
}

// +kubebuilder:object:root=true
// KafkaBridgeList contains a list of KafkaBridge instances.
type KafkaBridgeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`

	// A list of KafkaBridge objects.
	Items []KafkaBridge `json:"items,omitempty"`
}

// The specification of the Kafka Bridge.
// +kubebuilder:object:generate=true
type KafkaBridgeSpec struct {
	// Kafka AdminClient related configuration.
	AdminClient *KafkaBridgeSpecAdminClient `json:"adminClient,omitempty" yaml:"adminClient,omitempty" mapstructure:"adminClient,omitempty"`

	// Authentication configuration for connecting to the cluster.
	Authentication *KafkaBridgeSpecAuthentication `json:"authentication,omitempty" yaml:"authentication,omitempty" mapstructure:"authentication,omitempty"`

	// A list of host:port pairs for establishing the initial connection to the Kafka
	// cluster.
	BootstrapServers string `json:"bootstrapServers" yaml:"bootstrapServers" mapstructure:"bootstrapServers"`

	// The image of the init container used for initializing the `client.rack`.
	ClientRackInitImage *string `json:"clientRackInitImage,omitempty" yaml:"clientRackInitImage,omitempty" mapstructure:"clientRackInitImage,omitempty"`

	// Kafka consumer related configuration.
	Consumer *KafkaBridgeSpecConsumer `json:"consumer,omitempty" yaml:"consumer,omitempty" mapstructure:"consumer,omitempty"`

	// Enable the metrics for the Kafka Bridge. Default is false.
	EnableMetrics *bool `json:"enableMetrics,omitempty" yaml:"enableMetrics,omitempty" mapstructure:"enableMetrics,omitempty"`

	// The HTTP related configuration.
	Http *KafkaBridgeSpecHttp `json:"http,omitempty" yaml:"http,omitempty" mapstructure:"http,omitempty"`

	// The container image used for Kafka Bridge pods. If no image name is explicitly
	// specified, the image name corresponds to the image specified in the Cluster
	// Operator configuration. If an image name is not defined in the Cluster Operator
	// configuration, a default value is used.
	Image *string `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// **Currently not supported** JVM Options for pods.
	JvmOptions *KafkaBridgeSpecJvmOptions `json:"jvmOptions,omitempty" yaml:"jvmOptions,omitempty" mapstructure:"jvmOptions,omitempty"`

	// Pod liveness checking.
	LivenessProbe *KafkaBridgeSpecLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// Logging configuration for Kafka Bridge.
	Logging *KafkaBridgeSpecLogging `json:"logging,omitempty" yaml:"logging,omitempty" mapstructure:"logging,omitempty"`

	// Kafka producer related configuration.
	Producer *KafkaBridgeSpecProducer `json:"producer,omitempty" yaml:"producer,omitempty" mapstructure:"producer,omitempty"`

	// Configuration of the node label which will be used as the client.rack consumer
	// configuration.
	Rack *KafkaBridgeSpecRack `json:"rack,omitempty" yaml:"rack,omitempty" mapstructure:"rack,omitempty"`

	// Pod readiness checking.
	ReadinessProbe *KafkaBridgeSpecReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// The number of pods in the `Deployment`.  Defaults to `1`.
	Replicas *int32 `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// CPU and memory resources to reserve.
	Resources *KafkaBridgeSpecResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Template for Kafka Bridge resources. The template allows users to specify how a
	// `Deployment` and `Pod` is generated.
	Template *KafkaBridgeSpecTemplate `json:"template,omitempty" yaml:"template,omitempty" mapstructure:"template,omitempty"`

	// TLS configuration for connecting Kafka Bridge to the cluster.
	Tls *KafkaBridgeSpecTls `json:"tls,omitempty" yaml:"tls,omitempty" mapstructure:"tls,omitempty"`

	// The configuration of tracing in Kafka Bridge.
	Tracing *KafkaBridgeSpecTracing `json:"tracing,omitempty" yaml:"tracing,omitempty" mapstructure:"tracing,omitempty"`
}

// Kafka AdminClient related configuration.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecAdminClient struct {
	// The Kafka AdminClient configuration used for AdminClient instances created by
	// the bridge.
	Config *apiextensions.JSON `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`
}

// Authentication configuration for connecting to the cluster.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecAuthentication struct {
	// Link to Kubernetes Secret containing the access token which was obtained from
	// the authorization server.
	AccessToken *KafkaBridgeSpecAuthenticationAccessToken `json:"accessToken,omitempty" yaml:"accessToken,omitempty" mapstructure:"accessToken,omitempty"`

	// Configure whether access token should be treated as JWT. This should be set to
	// `false` if the authorization server returns opaque tokens. Defaults to `true`.
	AccessTokenIsJwt *bool `json:"accessTokenIsJwt,omitempty" yaml:"accessTokenIsJwt,omitempty" mapstructure:"accessTokenIsJwt,omitempty"`

	// Path to the token file containing an access token to be used for
	// authentication.
	AccessTokenLocation *string `json:"accessTokenLocation,omitempty" yaml:"accessTokenLocation,omitempty" mapstructure:"accessTokenLocation,omitempty"`

	// OAuth audience to use when authenticating against the authorization server.
	// Some authorization servers require the audience to be explicitly set. The
	// possible values depend on how the authorization server is configured. By
	// default, `audience` is not specified when performing the token endpoint
	// request.
	Audience *string `json:"audience,omitempty" yaml:"audience,omitempty" mapstructure:"audience,omitempty"`

	// Reference to the `Secret` which holds the certificate and private key pair.
	CertificateAndKey *KafkaBridgeSpecAuthenticationCertificateAndKey `json:"certificateAndKey,omitempty" yaml:"certificateAndKey,omitempty" mapstructure:"certificateAndKey,omitempty"`

	// Link to Kubernetes secret containing the client assertion which was manually
	// configured for the client.
	ClientAssertion *KafkaBridgeSpecAuthenticationClientAssertion `json:"clientAssertion,omitempty" yaml:"clientAssertion,omitempty" mapstructure:"clientAssertion,omitempty"`

	// Path to the file containing the client assertion to be used for authentication.
	ClientAssertionLocation *string `json:"clientAssertionLocation,omitempty" yaml:"clientAssertionLocation,omitempty" mapstructure:"clientAssertionLocation,omitempty"`

	// The client assertion type. If not set, and either `clientAssertion` or
	// `clientAssertionLocation` is configured, this value defaults to
	// `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`.
	ClientAssertionType *string `json:"clientAssertionType,omitempty" yaml:"clientAssertionType,omitempty" mapstructure:"clientAssertionType,omitempty"`

	// OAuth Client ID which the Kafka client can use to authenticate against the
	// OAuth server and use the token endpoint URI.
	ClientId *string `json:"clientId,omitempty" yaml:"clientId,omitempty" mapstructure:"clientId,omitempty"`

	// Link to Kubernetes Secret containing the OAuth client secret which the Kafka
	// client can use to authenticate against the OAuth server and use the token
	// endpoint URI.
	ClientSecret *KafkaBridgeSpecAuthenticationClientSecret `json:"clientSecret,omitempty" yaml:"clientSecret,omitempty" mapstructure:"clientSecret,omitempty"`

	// The connect timeout in seconds when connecting to authorization server. If not
	// set, the effective connect timeout is 60 seconds.
	ConnectTimeoutSeconds *int32 `json:"connectTimeoutSeconds,omitempty" yaml:"connectTimeoutSeconds,omitempty" mapstructure:"connectTimeoutSeconds,omitempty"`

	// Enable or disable TLS hostname verification. Default value is `false`.
	DisableTlsHostnameVerification *bool `json:"disableTlsHostnameVerification,omitempty" yaml:"disableTlsHostnameVerification,omitempty" mapstructure:"disableTlsHostnameVerification,omitempty"`

	// Enable or disable OAuth metrics. Default value is `false`.
	EnableMetrics *bool `json:"enableMetrics,omitempty" yaml:"enableMetrics,omitempty" mapstructure:"enableMetrics,omitempty"`

	// The maximum number of retries to attempt if an initial HTTP request fails. If
	// not set, the default is to not attempt any retries.
	HttpRetries *int32 `json:"httpRetries,omitempty" yaml:"httpRetries,omitempty" mapstructure:"httpRetries,omitempty"`

	// The pause to take before retrying a failed HTTP request. If not set, the
	// default is to not pause at all but to immediately repeat a request.
	HttpRetryPauseMs *int32 `json:"httpRetryPauseMs,omitempty" yaml:"httpRetryPauseMs,omitempty" mapstructure:"httpRetryPauseMs,omitempty"`

	// Whether the Accept header should be set in requests to the authorization
	// servers. The default value is `true`.
	IncludeAcceptHeader *bool `json:"includeAcceptHeader,omitempty" yaml:"includeAcceptHeader,omitempty" mapstructure:"includeAcceptHeader,omitempty"`

	// Set or limit time-to-live of the access tokens to the specified number of
	// seconds. This should be set if the authorization server returns opaque tokens.
	MaxTokenExpirySeconds *int32 `json:"maxTokenExpirySeconds,omitempty" yaml:"maxTokenExpirySeconds,omitempty" mapstructure:"maxTokenExpirySeconds,omitempty"`

	// Reference to the `Secret` which holds the password.
	PasswordSecret *KafkaBridgeSpecAuthenticationPasswordSecret `json:"passwordSecret,omitempty" yaml:"passwordSecret,omitempty" mapstructure:"passwordSecret,omitempty"`

	// The read timeout in seconds when connecting to authorization server. If not
	// set, the effective read timeout is 60 seconds.
	ReadTimeoutSeconds *int32 `json:"readTimeoutSeconds,omitempty" yaml:"readTimeoutSeconds,omitempty" mapstructure:"readTimeoutSeconds,omitempty"`

	// Link to Kubernetes Secret containing the refresh token which can be used to
	// obtain access token from the authorization server.
	RefreshToken *KafkaBridgeSpecAuthenticationRefreshToken `json:"refreshToken,omitempty" yaml:"refreshToken,omitempty" mapstructure:"refreshToken,omitempty"`

	// SASL extensions parameters.
	SaslExtensions map[string]string `json:"saslExtensions,omitempty" yaml:"saslExtensions,omitempty" mapstructure:"saslExtensions,omitempty"`

	// OAuth scope to use when authenticating against the authorization server. Some
	// authorization servers require this to be set. The possible values depend on how
	// authorization server is configured. By default `scope` is not specified when
	// doing the token endpoint request.
	Scope *string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Trusted certificates for TLS connection to the OAuth server.
	TlsTrustedCertificates []KafkaBridgeSpecAuthenticationTlsTrustedCertificatesElem `json:"tlsTrustedCertificates,omitempty" yaml:"tlsTrustedCertificates,omitempty" mapstructure:"tlsTrustedCertificates,omitempty"`

	// Authorization server token endpoint URI.
	TokenEndpointUri *string `json:"tokenEndpointUri,omitempty" yaml:"tokenEndpointUri,omitempty" mapstructure:"tokenEndpointUri,omitempty"`

	// Authentication type. Currently the supported types are `tls`, `scram-sha-256`,
	// `scram-sha-512`, `plain`, and 'oauth'. `scram-sha-256` and `scram-sha-512`
	// types use SASL SCRAM-SHA-256 and SASL SCRAM-SHA-512 Authentication,
	// respectively. `plain` type uses SASL PLAIN Authentication. `oauth` type uses
	// SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication.
	// The `tls` type is supported only over TLS connections.
	Type KafkaBridgeSpecAuthenticationType `json:"type" yaml:"type" mapstructure:"type"`

	// Username used for the authentication.
	Username *string `json:"username,omitempty" yaml:"username,omitempty" mapstructure:"username,omitempty"`
}

// Link to Kubernetes Secret containing the access token which was obtained from
// the authorization server.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecAuthenticationAccessToken struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthenticationAccessToken) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaBridgeSpecAuthenticationAccessToken: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaBridgeSpecAuthenticationAccessToken: required")
	}
	type Plain KafkaBridgeSpecAuthenticationAccessToken
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecAuthenticationAccessToken(plain)
	return nil
}

// Reference to the `Secret` which holds the certificate and private key pair.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecAuthenticationCertificateAndKey struct {
	// The name of the file certificate in the Secret.
	Certificate string `json:"certificate" yaml:"certificate" mapstructure:"certificate"`

	// The name of the private key in the Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthenticationCertificateAndKey) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["certificate"]; raw != nil && !ok {
		return fmt.Errorf("field certificate in KafkaBridgeSpecAuthenticationCertificateAndKey: required")
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaBridgeSpecAuthenticationCertificateAndKey: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaBridgeSpecAuthenticationCertificateAndKey: required")
	}
	type Plain KafkaBridgeSpecAuthenticationCertificateAndKey
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecAuthenticationCertificateAndKey(plain)
	return nil
}

// Link to Kubernetes secret containing the client assertion which was manually
// configured for the client.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecAuthenticationClientAssertion struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthenticationClientAssertion) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaBridgeSpecAuthenticationClientAssertion: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaBridgeSpecAuthenticationClientAssertion: required")
	}
	type Plain KafkaBridgeSpecAuthenticationClientAssertion
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecAuthenticationClientAssertion(plain)
	return nil
}

// Link to Kubernetes Secret containing the OAuth client secret which the Kafka
// client can use to authenticate against the OAuth server and use the token
// endpoint URI.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecAuthenticationClientSecret struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthenticationClientSecret) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaBridgeSpecAuthenticationClientSecret: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaBridgeSpecAuthenticationClientSecret: required")
	}
	type Plain KafkaBridgeSpecAuthenticationClientSecret
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecAuthenticationClientSecret(plain)
	return nil
}

// Reference to the `Secret` which holds the password.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecAuthenticationPasswordSecret struct {
	// The name of the key in the Secret under which the password is stored.
	Password string `json:"password" yaml:"password" mapstructure:"password"`

	// The name of the Secret containing the password.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthenticationPasswordSecret) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["password"]; raw != nil && !ok {
		return fmt.Errorf("field password in KafkaBridgeSpecAuthenticationPasswordSecret: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaBridgeSpecAuthenticationPasswordSecret: required")
	}
	type Plain KafkaBridgeSpecAuthenticationPasswordSecret
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecAuthenticationPasswordSecret(plain)
	return nil
}

// Link to Kubernetes Secret containing the refresh token which can be used to
// obtain access token from the authorization server.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecAuthenticationRefreshToken struct {
	// The key under which the secret value is stored in the Kubernetes Secret.
	Key string `json:"key" yaml:"key" mapstructure:"key"`

	// The name of the Kubernetes Secret containing the secret value.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthenticationRefreshToken) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["key"]; raw != nil && !ok {
		return fmt.Errorf("field key in KafkaBridgeSpecAuthenticationRefreshToken: required")
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaBridgeSpecAuthenticationRefreshToken: required")
	}
	type Plain KafkaBridgeSpecAuthenticationRefreshToken
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecAuthenticationRefreshToken(plain)
	return nil
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecAuthenticationTlsTrustedCertificatesElem struct {
	// The name of the file certificate in the secret.
	Certificate *string `json:"certificate,omitempty" yaml:"certificate,omitempty" mapstructure:"certificate,omitempty"`

	// Pattern for the certificate files in the secret. Use the
	// link:https://en.wikipedia.org/wiki/Glob_(programming)[_glob syntax_] for the
	// pattern. All files in the secret that match the pattern are used.
	Pattern *string `json:"pattern,omitempty" yaml:"pattern,omitempty" mapstructure:"pattern,omitempty"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthenticationTlsTrustedCertificatesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaBridgeSpecAuthenticationTlsTrustedCertificatesElem: required")
	}
	type Plain KafkaBridgeSpecAuthenticationTlsTrustedCertificatesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecAuthenticationTlsTrustedCertificatesElem(plain)
	return nil
}

type KafkaBridgeSpecAuthenticationType string

const KafkaBridgeSpecAuthenticationTypeOauth KafkaBridgeSpecAuthenticationType = "oauth"
const KafkaBridgeSpecAuthenticationTypePlain KafkaBridgeSpecAuthenticationType = "plain"
const KafkaBridgeSpecAuthenticationTypeScramSha256 KafkaBridgeSpecAuthenticationType = "scram-sha-256"
const KafkaBridgeSpecAuthenticationTypeScramSha512 KafkaBridgeSpecAuthenticationType = "scram-sha-512"
const KafkaBridgeSpecAuthenticationTypeTls KafkaBridgeSpecAuthenticationType = "tls"

var enumValues_KafkaBridgeSpecAuthenticationType = []interface{}{
	"tls",
	"scram-sha-256",
	"scram-sha-512",
	"plain",
	"oauth",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthenticationType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaBridgeSpecAuthenticationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaBridgeSpecAuthenticationType, v)
	}
	*j = KafkaBridgeSpecAuthenticationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecAuthentication) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaBridgeSpecAuthentication: required")
	}
	type Plain KafkaBridgeSpecAuthentication
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecAuthentication(plain)
	return nil
}

// Kafka consumer related configuration.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecConsumer struct {
	// The Kafka consumer configuration used for consumer instances created by the
	// bridge. Properties with the following prefixes cannot be set: ssl.,
	// bootstrap.servers, group.id, sasl., security. (with the exception of:
	// ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol,
	// ssl.enabled.protocols).
	Config *apiextensions.JSON `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Whether the HTTP consumer should be enabled or disabled. The default is enabled
	// (`true`).
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// The timeout in seconds for deleting inactive consumers, default is -1
	// (disabled).
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// The HTTP related configuration.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecHttp struct {
	// CORS configuration for the HTTP Bridge.
	Cors *KafkaBridgeSpecHttpCors `json:"cors,omitempty" yaml:"cors,omitempty" mapstructure:"cors,omitempty"`

	// The port which is the server listening on.
	Port *int32 `json:"port,omitempty" yaml:"port,omitempty" mapstructure:"port,omitempty"`
}

// CORS configuration for the HTTP Bridge.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecHttpCors struct {
	// List of allowed HTTP methods.
	AllowedMethods []string `json:"allowedMethods" yaml:"allowedMethods" mapstructure:"allowedMethods"`

	// List of allowed origins. Java regular expressions can be used.
	AllowedOrigins []string `json:"allowedOrigins" yaml:"allowedOrigins" mapstructure:"allowedOrigins"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecHttpCors) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["allowedMethods"]; raw != nil && !ok {
		return fmt.Errorf("field allowedMethods in KafkaBridgeSpecHttpCors: required")
	}
	if _, ok := raw["allowedOrigins"]; raw != nil && !ok {
		return fmt.Errorf("field allowedOrigins in KafkaBridgeSpecHttpCors: required")
	}
	type Plain KafkaBridgeSpecHttpCors
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecHttpCors(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecHttp) UnmarshalJSON(value []byte) error {
	type Plain KafkaBridgeSpecHttp
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Port != nil && 1023 > *plain.Port {
		return fmt.Errorf("field %s: must be >= %v", "port", 1023)
	}
	*j = KafkaBridgeSpecHttp(plain)
	return nil
}

// **Currently not supported** JVM Options for pods.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecJvmOptions struct {
	// A map of -XX options to the JVM.
	XX map[string]string `json:"-XX,omitempty" yaml:"-XX,omitempty" mapstructure:"-XX,omitempty"`

	// -Xms option to to the JVM.
	Xms *string `json:"-Xms,omitempty" yaml:"-Xms,omitempty" mapstructure:"-Xms,omitempty"`

	// -Xmx option to to the JVM.
	Xmx *string `json:"-Xmx,omitempty" yaml:"-Xmx,omitempty" mapstructure:"-Xmx,omitempty"`

	// Specifies whether the Garbage Collection logging is enabled. The default is
	// false.
	GcLoggingEnabled *bool `json:"gcLoggingEnabled,omitempty" yaml:"gcLoggingEnabled,omitempty" mapstructure:"gcLoggingEnabled,omitempty"`

	// A map of additional system properties which will be passed using the `-D`
	// option to the JVM.
	JavaSystemProperties []KafkaBridgeSpecJvmOptionsJavaSystemPropertiesElem `json:"javaSystemProperties,omitempty" yaml:"javaSystemProperties,omitempty" mapstructure:"javaSystemProperties,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecJvmOptionsJavaSystemPropertiesElem struct {
	// The system property name.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The system property value.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecJvmOptions) UnmarshalJSON(value []byte) error {
	type Plain KafkaBridgeSpecJvmOptions
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Xms != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[mMgG]?$`, string(*plain.Xms)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Xms", `^[0-9]+[mMgG]?$`)
		}
	}
	if plain.Xmx != nil {
		if matched, _ := regexp.MatchString(`^[0-9]+[mMgG]?$`, string(*plain.Xmx)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Xmx", `^[0-9]+[mMgG]?$`)
		}
	}
	*j = KafkaBridgeSpecJvmOptions(plain)
	return nil
}

// Pod liveness checking.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecLivenessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecLivenessProbe) UnmarshalJSON(value []byte) error {
	type Plain KafkaBridgeSpecLivenessProbe
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.FailureThreshold != nil && 1 > *plain.FailureThreshold {
		return fmt.Errorf("field %s: must be >= %v", "failureThreshold", 1)
	}
	if plain.InitialDelaySeconds != nil && 0 > *plain.InitialDelaySeconds {
		return fmt.Errorf("field %s: must be >= %v", "initialDelaySeconds", 0)
	}
	if plain.PeriodSeconds != nil && 1 > *plain.PeriodSeconds {
		return fmt.Errorf("field %s: must be >= %v", "periodSeconds", 1)
	}
	if plain.SuccessThreshold != nil && 1 > *plain.SuccessThreshold {
		return fmt.Errorf("field %s: must be >= %v", "successThreshold", 1)
	}
	if plain.TimeoutSeconds != nil && 1 > *plain.TimeoutSeconds {
		return fmt.Errorf("field %s: must be >= %v", "timeoutSeconds", 1)
	}
	*j = KafkaBridgeSpecLivenessProbe(plain)
	return nil
}

// Logging configuration for Kafka Bridge.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecLogging struct {
	// A Map from logger name to logger level.
	Loggers map[string]string `json:"loggers,omitempty" yaml:"loggers,omitempty" mapstructure:"loggers,omitempty"`

	// Logging type, must be either 'inline' or 'external'.
	Type KafkaBridgeSpecLoggingType `json:"type" yaml:"type" mapstructure:"type"`

	// `ConfigMap` entry where the logging configuration is stored.
	ValueFrom *KafkaBridgeSpecLoggingValueFrom `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty" mapstructure:"valueFrom,omitempty"`
}

type KafkaBridgeSpecLoggingType string

const KafkaBridgeSpecLoggingTypeExternal KafkaBridgeSpecLoggingType = "external"
const KafkaBridgeSpecLoggingTypeInline KafkaBridgeSpecLoggingType = "inline"

var enumValues_KafkaBridgeSpecLoggingType = []interface{}{
	"inline",
	"external",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecLoggingType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaBridgeSpecLoggingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaBridgeSpecLoggingType, v)
	}
	*j = KafkaBridgeSpecLoggingType(v)
	return nil
}

// `ConfigMap` entry where the logging configuration is stored.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecLoggingValueFrom struct {
	// Reference to the key in the ConfigMap containing the configuration.
	ConfigMapKeyRef *KafkaBridgeSpecLoggingValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`
}

// Reference to the key in the ConfigMap containing the configuration.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecLoggingValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecLogging) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaBridgeSpecLogging: required")
	}
	type Plain KafkaBridgeSpecLogging
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecLogging(plain)
	return nil
}

// Kafka producer related configuration.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecProducer struct {
	// The Kafka producer configuration used for producer instances created by the
	// bridge. Properties with the following prefixes cannot be set: ssl.,
	// bootstrap.servers, sasl., security. (with the exception of:
	// ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol,
	// ssl.enabled.protocols).
	Config *apiextensions.JSON `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Whether the HTTP producer should be enabled or disabled. The default is enabled
	// (`true`).
	Enabled *bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

// Configuration of the node label which will be used as the client.rack consumer
// configuration.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecRack struct {
	// A key that matches labels assigned to the Kubernetes cluster nodes. The value
	// of the label is used to set a broker's `broker.rack` config, and the
	// `client.rack` config for Kafka Connect or MirrorMaker 2.
	TopologyKey string `json:"topologyKey" yaml:"topologyKey" mapstructure:"topologyKey"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecRack) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["topologyKey"]; raw != nil && !ok {
		return fmt.Errorf("field topologyKey in KafkaBridgeSpecRack: required")
	}
	type Plain KafkaBridgeSpecRack
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecRack(plain)
	return nil
}

// Pod readiness checking.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecReadinessProbe struct {
	// Minimum consecutive failures for the probe to be considered failed after having
	// succeeded. Defaults to 3. Minimum value is 1.
	FailureThreshold *int32 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// The initial delay before first the health is first checked. Default to 15
	// seconds. Minimum value is 0.
	InitialDelaySeconds *int32 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// How often (in seconds) to perform the probe. Default to 10 seconds. Minimum
	// value is 1.
	PeriodSeconds *int32 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after
	// having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
	SuccessThreshold *int32 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// The timeout for each attempted health check. Default to 5 seconds. Minimum
	// value is 1.
	TimeoutSeconds *int32 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecReadinessProbe) UnmarshalJSON(value []byte) error {
	type Plain KafkaBridgeSpecReadinessProbe
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.FailureThreshold != nil && 1 > *plain.FailureThreshold {
		return fmt.Errorf("field %s: must be >= %v", "failureThreshold", 1)
	}
	if plain.InitialDelaySeconds != nil && 0 > *plain.InitialDelaySeconds {
		return fmt.Errorf("field %s: must be >= %v", "initialDelaySeconds", 0)
	}
	if plain.PeriodSeconds != nil && 1 > *plain.PeriodSeconds {
		return fmt.Errorf("field %s: must be >= %v", "periodSeconds", 1)
	}
	if plain.SuccessThreshold != nil && 1 > *plain.SuccessThreshold {
		return fmt.Errorf("field %s: must be >= %v", "successThreshold", 1)
	}
	if plain.TimeoutSeconds != nil && 1 > *plain.TimeoutSeconds {
		return fmt.Errorf("field %s: must be >= %v", "timeoutSeconds", 1)
	}
	*j = KafkaBridgeSpecReadinessProbe(plain)
	return nil
}

// CPU and memory resources to reserve.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecResources struct {
	// Claims corresponds to the JSON schema field "claims".
	Claims []KafkaBridgeSpecResourcesClaimsElem `json:"claims,omitempty" yaml:"claims,omitempty" mapstructure:"claims,omitempty"`

	// Limits corresponds to the JSON schema field "limits".
	Limits *apiextensions.JSON `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// Requests corresponds to the JSON schema field "requests".
	Requests *apiextensions.JSON `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecResourcesClaimsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Request corresponds to the JSON schema field "request".
	Request *string `json:"request,omitempty" yaml:"request,omitempty" mapstructure:"request,omitempty"`
}

// Template for Kafka Bridge resources. The template allows users to specify how a
// `Deployment` and `Pod` is generated.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplate struct {
	// Template for Kafka Bridge API `Service`.
	ApiService *KafkaBridgeSpecTemplateApiService `json:"apiService,omitempty" yaml:"apiService,omitempty" mapstructure:"apiService,omitempty"`

	// Template for the Kafka Bridge container.
	BridgeContainer *KafkaBridgeSpecTemplateBridgeContainer `json:"bridgeContainer,omitempty" yaml:"bridgeContainer,omitempty" mapstructure:"bridgeContainer,omitempty"`

	// Template for the Kafka Bridge ClusterRoleBinding.
	ClusterRoleBinding *KafkaBridgeSpecTemplateClusterRoleBinding `json:"clusterRoleBinding,omitempty" yaml:"clusterRoleBinding,omitempty" mapstructure:"clusterRoleBinding,omitempty"`

	// Template for Kafka Bridge `Deployment`.
	Deployment *KafkaBridgeSpecTemplateDeployment `json:"deployment,omitempty" yaml:"deployment,omitempty" mapstructure:"deployment,omitempty"`

	// Template for the Kafka Bridge init container.
	InitContainer *KafkaBridgeSpecTemplateInitContainer `json:"initContainer,omitempty" yaml:"initContainer,omitempty" mapstructure:"initContainer,omitempty"`

	// Template for Kafka Bridge `Pods`.
	Pod *KafkaBridgeSpecTemplatePod `json:"pod,omitempty" yaml:"pod,omitempty" mapstructure:"pod,omitempty"`

	// Template for Kafka Bridge `PodDisruptionBudget`.
	PodDisruptionBudget *KafkaBridgeSpecTemplatePodDisruptionBudget `json:"podDisruptionBudget,omitempty" yaml:"podDisruptionBudget,omitempty" mapstructure:"podDisruptionBudget,omitempty"`

	// Template for the Kafka Bridge service account.
	ServiceAccount *KafkaBridgeSpecTemplateServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`
}

// Template for Kafka Bridge API `Service`.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateApiService struct {
	// Specifies the IP Families used by the service. Available options are `IPv4` and
	// `IPv6`. If unspecified, Kubernetes will choose the default value based on the
	// `ipFamilyPolicy` setting.
	IpFamilies []KafkaBridgeSpecTemplateApiServiceIpFamiliesElem `json:"ipFamilies,omitempty" yaml:"ipFamilies,omitempty" mapstructure:"ipFamilies,omitempty"`

	// Specifies the IP Family Policy used by the service. Available options are
	// `SingleStack`, `PreferDualStack` and `RequireDualStack`. `SingleStack` is for a
	// single IP family. `PreferDualStack` is for two IP families on dual-stack
	// configured clusters or a single IP family on single-stack clusters.
	// `RequireDualStack` fails unless there are two IP families on dual-stack
	// configured clusters. If unspecified, Kubernetes will choose the default value
	// based on the service type.
	IpFamilyPolicy *KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy `json:"ipFamilyPolicy,omitempty" yaml:"ipFamilyPolicy,omitempty" mapstructure:"ipFamilyPolicy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaBridgeSpecTemplateApiServiceMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

type KafkaBridgeSpecTemplateApiServiceIpFamiliesElem string

const KafkaBridgeSpecTemplateApiServiceIpFamiliesElemIPv4 KafkaBridgeSpecTemplateApiServiceIpFamiliesElem = "IPv4"
const KafkaBridgeSpecTemplateApiServiceIpFamiliesElemIPv6 KafkaBridgeSpecTemplateApiServiceIpFamiliesElem = "IPv6"

var enumValues_KafkaBridgeSpecTemplateApiServiceIpFamiliesElem = []interface{}{
	"IPv4",
	"IPv6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTemplateApiServiceIpFamiliesElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaBridgeSpecTemplateApiServiceIpFamiliesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaBridgeSpecTemplateApiServiceIpFamiliesElem, v)
	}
	*j = KafkaBridgeSpecTemplateApiServiceIpFamiliesElem(v)
	return nil
}

type KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy string

const KafkaBridgeSpecTemplateApiServiceIpFamilyPolicyPreferDualStack KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy = "PreferDualStack"
const KafkaBridgeSpecTemplateApiServiceIpFamilyPolicyRequireDualStack KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy = "RequireDualStack"
const KafkaBridgeSpecTemplateApiServiceIpFamilyPolicySingleStack KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy = "SingleStack"

var enumValues_KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy = []interface{}{
	"SingleStack",
	"PreferDualStack",
	"RequireDualStack",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy, v)
	}
	*j = KafkaBridgeSpecTemplateApiServiceIpFamilyPolicy(v)
	return nil
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateApiServiceMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for the Kafka Bridge container.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaBridgeSpecTemplateBridgeContainerEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaBridgeSpecTemplateBridgeContainerSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// Additional volume mounts which should be applied to the container.
	VolumeMounts []KafkaBridgeSpecTemplateBridgeContainerVolumeMountsElem `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`

	// Reference to the secret or config map property to which the environment
	// variable is set.
	ValueFrom *KafkaBridgeSpecTemplateBridgeContainerEnvElemValueFrom `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty" mapstructure:"valueFrom,omitempty"`
}

// Reference to the secret or config map property to which the environment variable
// is set.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerEnvElemValueFrom struct {
	// Reference to a key in a config map.
	ConfigMapKeyRef *KafkaBridgeSpecTemplateBridgeContainerEnvElemValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`

	// Reference to a key in a secret.
	SecretKeyRef *KafkaBridgeSpecTemplateBridgeContainerEnvElemValueFromSecretKeyRef `json:"secretKeyRef,omitempty" yaml:"secretKeyRef,omitempty" mapstructure:"secretKeyRef,omitempty"`
}

// Reference to a key in a config map.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerEnvElemValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Reference to a key in a secret.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerEnvElemValueFromSecretKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Security context for the container.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// AppArmorProfile corresponds to the JSON schema field "appArmorProfile".
	AppArmorProfile *KafkaBridgeSpecTemplateBridgeContainerSecurityContextAppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty" mapstructure:"appArmorProfile,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty" yaml:"privileged,omitempty" mapstructure:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty" yaml:"procMount,omitempty" mapstructure:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty" mapstructure:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty" yaml:"windowsOptions,omitempty" mapstructure:"windowsOptions,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerSecurityContextAppArmorProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty" yaml:"add,omitempty" mapstructure:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty" yaml:"gmsaCredentialSpec,omitempty" mapstructure:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty" yaml:"gmsaCredentialSpecName,omitempty" mapstructure:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty" yaml:"hostProcess,omitempty" mapstructure:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty" yaml:"runAsUserName,omitempty" mapstructure:"runAsUserName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateBridgeContainerVolumeMountsElem struct {
	// MountPath corresponds to the JSON schema field "mountPath".
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// MountPropagation corresponds to the JSON schema field "mountPropagation".
	MountPropagation *string `json:"mountPropagation,omitempty" yaml:"mountPropagation,omitempty" mapstructure:"mountPropagation,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// RecursiveReadOnly corresponds to the JSON schema field "recursiveReadOnly".
	RecursiveReadOnly *string `json:"recursiveReadOnly,omitempty" yaml:"recursiveReadOnly,omitempty" mapstructure:"recursiveReadOnly,omitempty"`

	// SubPath corresponds to the JSON schema field "subPath".
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// SubPathExpr corresponds to the JSON schema field "subPathExpr".
	SubPathExpr *string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}

// Template for the Kafka Bridge ClusterRoleBinding.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateClusterRoleBinding struct {
	// Metadata applied to the resource.
	Metadata *KafkaBridgeSpecTemplateClusterRoleBindingMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateClusterRoleBindingMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for Kafka Bridge `Deployment`.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateDeployment struct {
	// Pod replacement strategy for deployment configuration changes. Valid values are
	// `RollingUpdate` and `Recreate`. Defaults to `RollingUpdate`.
	DeploymentStrategy *KafkaBridgeSpecTemplateDeploymentDeploymentStrategy `json:"deploymentStrategy,omitempty" yaml:"deploymentStrategy,omitempty" mapstructure:"deploymentStrategy,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaBridgeSpecTemplateDeploymentMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

type KafkaBridgeSpecTemplateDeploymentDeploymentStrategy string

const KafkaBridgeSpecTemplateDeploymentDeploymentStrategyRecreate KafkaBridgeSpecTemplateDeploymentDeploymentStrategy = "Recreate"
const KafkaBridgeSpecTemplateDeploymentDeploymentStrategyRollingUpdate KafkaBridgeSpecTemplateDeploymentDeploymentStrategy = "RollingUpdate"

var enumValues_KafkaBridgeSpecTemplateDeploymentDeploymentStrategy = []interface{}{
	"RollingUpdate",
	"Recreate",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTemplateDeploymentDeploymentStrategy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaBridgeSpecTemplateDeploymentDeploymentStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaBridgeSpecTemplateDeploymentDeploymentStrategy, v)
	}
	*j = KafkaBridgeSpecTemplateDeploymentDeploymentStrategy(v)
	return nil
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateDeploymentMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Template for the Kafka Bridge init container.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainer struct {
	// Environment variables which should be applied to the container.
	Env []KafkaBridgeSpecTemplateInitContainerEnvElem `json:"env,omitempty" yaml:"env,omitempty" mapstructure:"env,omitempty"`

	// Security context for the container.
	SecurityContext *KafkaBridgeSpecTemplateInitContainerSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// Additional volume mounts which should be applied to the container.
	VolumeMounts []KafkaBridgeSpecTemplateInitContainerVolumeMountsElem `json:"volumeMounts,omitempty" yaml:"volumeMounts,omitempty" mapstructure:"volumeMounts,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerEnvElem struct {
	// The environment variable key.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The environment variable value.
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`

	// Reference to the secret or config map property to which the environment
	// variable is set.
	ValueFrom *KafkaBridgeSpecTemplateInitContainerEnvElemValueFrom `json:"valueFrom,omitempty" yaml:"valueFrom,omitempty" mapstructure:"valueFrom,omitempty"`
}

// Reference to the secret or config map property to which the environment variable
// is set.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerEnvElemValueFrom struct {
	// Reference to a key in a config map.
	ConfigMapKeyRef *KafkaBridgeSpecTemplateInitContainerEnvElemValueFromConfigMapKeyRef `json:"configMapKeyRef,omitempty" yaml:"configMapKeyRef,omitempty" mapstructure:"configMapKeyRef,omitempty"`

	// Reference to a key in a secret.
	SecretKeyRef *KafkaBridgeSpecTemplateInitContainerEnvElemValueFromSecretKeyRef `json:"secretKeyRef,omitempty" yaml:"secretKeyRef,omitempty" mapstructure:"secretKeyRef,omitempty"`
}

// Reference to a key in a config map.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerEnvElemValueFromConfigMapKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Reference to a key in a secret.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerEnvElemValueFromSecretKeyRef struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// Security context for the container.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerSecurityContext struct {
	// AllowPrivilegeEscalation corresponds to the JSON schema field
	// "allowPrivilegeEscalation".
	AllowPrivilegeEscalation *bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// AppArmorProfile corresponds to the JSON schema field "appArmorProfile".
	AppArmorProfile *KafkaBridgeSpecTemplateInitContainerSecurityContextAppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty" mapstructure:"appArmorProfile,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Privileged corresponds to the JSON schema field "privileged".
	Privileged *bool `json:"privileged,omitempty" yaml:"privileged,omitempty" mapstructure:"privileged,omitempty"`

	// ProcMount corresponds to the JSON schema field "procMount".
	ProcMount *string `json:"procMount,omitempty" yaml:"procMount,omitempty" mapstructure:"procMount,omitempty"`

	// ReadOnlyRootFilesystem corresponds to the JSON schema field
	// "readOnlyRootFilesystem".
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty" mapstructure:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions `json:"windowsOptions,omitempty" yaml:"windowsOptions,omitempty" mapstructure:"windowsOptions,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerSecurityContextAppArmorProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerSecurityContextCapabilities struct {
	// Add corresponds to the JSON schema field "add".
	Add []string `json:"add,omitempty" yaml:"add,omitempty" mapstructure:"add,omitempty"`

	// Drop corresponds to the JSON schema field "drop".
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty" yaml:"gmsaCredentialSpec,omitempty" mapstructure:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty" yaml:"gmsaCredentialSpecName,omitempty" mapstructure:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty" yaml:"hostProcess,omitempty" mapstructure:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty" yaml:"runAsUserName,omitempty" mapstructure:"runAsUserName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateInitContainerVolumeMountsElem struct {
	// MountPath corresponds to the JSON schema field "mountPath".
	MountPath *string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// MountPropagation corresponds to the JSON schema field "mountPropagation".
	MountPropagation *string `json:"mountPropagation,omitempty" yaml:"mountPropagation,omitempty" mapstructure:"mountPropagation,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// RecursiveReadOnly corresponds to the JSON schema field "recursiveReadOnly".
	RecursiveReadOnly *string `json:"recursiveReadOnly,omitempty" yaml:"recursiveReadOnly,omitempty" mapstructure:"recursiveReadOnly,omitempty"`

	// SubPath corresponds to the JSON schema field "subPath".
	SubPath *string `json:"subPath,omitempty" yaml:"subPath,omitempty" mapstructure:"subPath,omitempty"`

	// SubPathExpr corresponds to the JSON schema field "subPathExpr".
	SubPathExpr *string `json:"subPathExpr,omitempty" yaml:"subPathExpr,omitempty" mapstructure:"subPathExpr,omitempty"`
}

// Template for Kafka Bridge `Pods`.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePod struct {
	// The pod's affinity rules.
	Affinity *KafkaBridgeSpecTemplatePodAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// The pod's DNSConfig. If specified, it will be merged to the generated DNS
	// configuration based on the DNSPolicy.
	DnsConfig *KafkaBridgeSpecTemplatePodDnsConfig `json:"dnsConfig,omitempty" yaml:"dnsConfig,omitempty" mapstructure:"dnsConfig,omitempty"`

	// The pod's DNSPolicy. Defaults to `ClusterFirst`. Valid values are
	// `ClusterFirstWithHostNet`, `ClusterFirst`, `Default` or `None`.
	DnsPolicy *KafkaBridgeSpecTemplatePodDnsPolicy `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty" mapstructure:"dnsPolicy,omitempty"`

	// Indicates whether information about services should be injected into Pod's
	// environment variables.
	EnableServiceLinks *bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// The pod's HostAliases. HostAliases is an optional list of hosts and IPs that
	// will be injected into the Pod's hosts file if specified.
	HostAliases []KafkaBridgeSpecTemplatePodHostAliasesElem `json:"hostAliases,omitempty" yaml:"hostAliases,omitempty" mapstructure:"hostAliases,omitempty"`

	// List of references to secrets in the same namespace to use for pulling any of
	// the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment
	// variable in Cluster Operator and the `imagePullSecrets` option are specified,
	// only the `imagePullSecrets` variable is used and the
	// `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
	ImagePullSecrets []KafkaBridgeSpecTemplatePodImagePullSecretsElem `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Metadata applied to the resource.
	Metadata *KafkaBridgeSpecTemplatePodMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The name of the priority class used to assign priority to the pods.
	PriorityClassName *string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// The name of the scheduler used to dispatch this `Pod`. If not specified, the
	// default scheduler will be used.
	SchedulerName *string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// Configures pod-level security attributes and common container settings.
	SecurityContext *KafkaBridgeSpecTemplatePodSecurityContext `json:"securityContext,omitempty" yaml:"securityContext,omitempty" mapstructure:"securityContext,omitempty"`

	// The grace period is the duration in seconds after the processes running in the
	// pod are sent a termination signal, and the time when the processes are forcibly
	// halted with a kill signal. Set this value to longer than the expected cleanup
	// time for your process. Value must be a non-negative integer. A zero value
	// indicates delete immediately. You might need to increase the grace period for
	// very large Kafka clusters, so that the Kafka brokers have enough time to
	// transfer their work to another broker before they are terminated. Defaults to
	// 30 seconds.
	TerminationGracePeriodSeconds *int32 `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty" mapstructure:"terminationGracePeriodSeconds,omitempty"`

	// Defines the total amount of pod memory allocated for the temporary `EmptyDir`
	// volume `/tmp`. Specify the allocation in memory units, for example, `100Mi` for
	// 100 mebibytes. Default value is `5Mi`. The `/tmp` volume is backed by pod
	// memory, not disk storage, so avoid setting a high value as it consumes pod
	// memory resources.
	TmpDirSizeLimit *string `json:"tmpDirSizeLimit,omitempty" yaml:"tmpDirSizeLimit,omitempty" mapstructure:"tmpDirSizeLimit,omitempty"`

	// The pod's tolerations.
	Tolerations []KafkaBridgeSpecTemplatePodTolerationsElem `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// The pod's topology spread constraints.
	TopologySpreadConstraints []KafkaBridgeSpecTemplatePodTopologySpreadConstraintsElem `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`

	// Additional volumes that can be mounted to the pod.
	Volumes []KafkaBridgeSpecTemplatePodVolumesElem `json:"volumes,omitempty" yaml:"volumes,omitempty" mapstructure:"volumes,omitempty"`
}

// The pod's affinity rules.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinity struct {
	// NodeAffinity corresponds to the JSON schema field "nodeAffinity".
	NodeAffinity *KafkaBridgeSpecTemplatePodAffinityNodeAffinity `json:"nodeAffinity,omitempty" yaml:"nodeAffinity,omitempty" mapstructure:"nodeAffinity,omitempty"`

	// PodAffinity corresponds to the JSON schema field "podAffinity".
	PodAffinity *KafkaBridgeSpecTemplatePodAffinityPodAffinity `json:"podAffinity,omitempty" yaml:"podAffinity,omitempty" mapstructure:"podAffinity,omitempty"`

	// PodAntiAffinity corresponds to the JSON schema field "podAntiAffinity".
	PodAntiAffinity *KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity `json:"podAntiAffinity,omitempty" yaml:"podAntiAffinity,omitempty" mapstructure:"podAntiAffinity,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution *KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// Preference corresponds to the JSON schema field "preference".
	Preference *KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference `json:"preference,omitempty" yaml:"preference,omitempty" mapstructure:"preference,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreference struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem `json:"matchFields,omitempty" yaml:"matchFields,omitempty" mapstructure:"matchFields,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPreferenceMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution struct {
	// NodeSelectorTerms corresponds to the JSON schema field "nodeSelectorTerms".
	NodeSelectorTerms []KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem `json:"nodeSelectorTerms,omitempty" yaml:"nodeSelectorTerms,omitempty" mapstructure:"nodeSelectorTerms,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElem struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchFields corresponds to the JSON schema field "matchFields".
	MatchFields []KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem `json:"matchFields,omitempty" yaml:"matchFields,omitempty" mapstructure:"matchFields,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsElemMatchFieldsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty" yaml:"podAffinityTerm,omitempty" mapstructure:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity struct {
	// PreferredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "preferredDuringSchedulingIgnoredDuringExecution".
	PreferredDuringSchedulingIgnoredDuringExecution []KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem `json:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"preferredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"preferredDuringSchedulingIgnoredDuringExecution,omitempty"`

	// RequiredDuringSchedulingIgnoredDuringExecution corresponds to the JSON schema
	// field "requiredDuringSchedulingIgnoredDuringExecution".
	RequiredDuringSchedulingIgnoredDuringExecution []KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem `json:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" yaml:"requiredDuringSchedulingIgnoredDuringExecution,omitempty" mapstructure:"requiredDuringSchedulingIgnoredDuringExecution,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElem struct {
	// PodAffinityTerm corresponds to the JSON schema field "podAffinityTerm".
	PodAffinityTerm *KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm `json:"podAffinityTerm,omitempty" yaml:"podAffinityTerm,omitempty" mapstructure:"podAffinityTerm,omitempty"`

	// Weight corresponds to the JSON schema field "weight".
	Weight *int32 `json:"weight,omitempty" yaml:"weight,omitempty" mapstructure:"weight,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTerm struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionElemPodAffinityTermNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MismatchLabelKeys corresponds to the JSON schema field "mismatchLabelKeys".
	MismatchLabelKeys []string `json:"mismatchLabelKeys,omitempty" yaml:"mismatchLabelKeys,omitempty" mapstructure:"mismatchLabelKeys,omitempty"`

	// NamespaceSelector corresponds to the JSON schema field "namespaceSelector".
	NamespaceSelector *KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector `json:"namespaceSelector,omitempty" yaml:"namespaceSelector,omitempty" mapstructure:"namespaceSelector,omitempty"`

	// Namespaces corresponds to the JSON schema field "namespaces".
	Namespaces []string `json:"namespaces,omitempty" yaml:"namespaces,omitempty" mapstructure:"namespaces,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionElemNamespaceSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// Template for Kafka Bridge `PodDisruptionBudget`.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodDisruptionBudget struct {
	// Maximum number of unavailable pods to allow automatic Pod eviction. A Pod
	// eviction is allowed when the `maxUnavailable` number of pods or fewer are
	// unavailable after the eviction. Setting this value to 0 prevents all voluntary
	// evictions, so the pods must be evicted manually. Defaults to 1.
	MaxUnavailable *int32 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty" mapstructure:"maxUnavailable,omitempty"`

	// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
	Metadata *KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata to apply to the `PodDisruptionBudgetTemplate` resource.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTemplatePodDisruptionBudget) UnmarshalJSON(value []byte) error {
	type Plain KafkaBridgeSpecTemplatePodDisruptionBudget
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.MaxUnavailable != nil && 0 > *plain.MaxUnavailable {
		return fmt.Errorf("field %s: must be >= %v", "maxUnavailable", 0)
	}
	*j = KafkaBridgeSpecTemplatePodDisruptionBudget(plain)
	return nil
}

// The pod's DNSConfig. If specified, it will be merged to the generated DNS
// configuration based on the DNSPolicy.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodDnsConfig struct {
	// Nameservers corresponds to the JSON schema field "nameservers".
	Nameservers []string `json:"nameservers,omitempty" yaml:"nameservers,omitempty" mapstructure:"nameservers,omitempty"`

	// Options corresponds to the JSON schema field "options".
	Options []KafkaBridgeSpecTemplatePodDnsConfigOptionsElem `json:"options,omitempty" yaml:"options,omitempty" mapstructure:"options,omitempty"`

	// Searches corresponds to the JSON schema field "searches".
	Searches []string `json:"searches,omitempty" yaml:"searches,omitempty" mapstructure:"searches,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodDnsConfigOptionsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type KafkaBridgeSpecTemplatePodDnsPolicy string

const KafkaBridgeSpecTemplatePodDnsPolicyClusterFirst KafkaBridgeSpecTemplatePodDnsPolicy = "ClusterFirst"
const KafkaBridgeSpecTemplatePodDnsPolicyClusterFirstWithHostNet KafkaBridgeSpecTemplatePodDnsPolicy = "ClusterFirstWithHostNet"
const KafkaBridgeSpecTemplatePodDnsPolicyDefault KafkaBridgeSpecTemplatePodDnsPolicy = "Default"
const KafkaBridgeSpecTemplatePodDnsPolicyNone KafkaBridgeSpecTemplatePodDnsPolicy = "None"

var enumValues_KafkaBridgeSpecTemplatePodDnsPolicy = []interface{}{
	"ClusterFirst",
	"ClusterFirstWithHostNet",
	"Default",
	"None",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTemplatePodDnsPolicy) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaBridgeSpecTemplatePodDnsPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaBridgeSpecTemplatePodDnsPolicy, v)
	}
	*j = KafkaBridgeSpecTemplatePodDnsPolicy(v)
	return nil
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodHostAliasesElem struct {
	// Hostnames corresponds to the JSON schema field "hostnames".
	Hostnames []string `json:"hostnames,omitempty" yaml:"hostnames,omitempty" mapstructure:"hostnames,omitempty"`

	// Ip corresponds to the JSON schema field "ip".
	Ip *string `json:"ip,omitempty" yaml:"ip,omitempty" mapstructure:"ip,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodImagePullSecretsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Configures pod-level security attributes and common container settings.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodSecurityContext struct {
	// AppArmorProfile corresponds to the JSON schema field "appArmorProfile".
	AppArmorProfile *KafkaBridgeSpecTemplatePodSecurityContextAppArmorProfile `json:"appArmorProfile,omitempty" yaml:"appArmorProfile,omitempty" mapstructure:"appArmorProfile,omitempty"`

	// FsGroup corresponds to the JSON schema field "fsGroup".
	FsGroup *int32 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// FsGroupChangePolicy corresponds to the JSON schema field "fsGroupChangePolicy".
	FsGroupChangePolicy *string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// RunAsGroup corresponds to the JSON schema field "runAsGroup".
	RunAsGroup *int32 `json:"runAsGroup,omitempty" yaml:"runAsGroup,omitempty" mapstructure:"runAsGroup,omitempty"`

	// RunAsNonRoot corresponds to the JSON schema field "runAsNonRoot".
	RunAsNonRoot *bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// RunAsUser corresponds to the JSON schema field "runAsUser".
	RunAsUser *int32 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeLinuxChangePolicy corresponds to the JSON schema field "seLinuxChangePolicy".
	SeLinuxChangePolicy *string `json:"seLinuxChangePolicy,omitempty" yaml:"seLinuxChangePolicy,omitempty" mapstructure:"seLinuxChangePolicy,omitempty"`

	// SeLinuxOptions corresponds to the JSON schema field "seLinuxOptions".
	SeLinuxOptions *KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions `json:"seLinuxOptions,omitempty" yaml:"seLinuxOptions,omitempty" mapstructure:"seLinuxOptions,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// SupplementalGroups corresponds to the JSON schema field "supplementalGroups".
	SupplementalGroups []int32 `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// SupplementalGroupsPolicy corresponds to the JSON schema field
	// "supplementalGroupsPolicy".
	SupplementalGroupsPolicy *string `json:"supplementalGroupsPolicy,omitempty" yaml:"supplementalGroupsPolicy,omitempty" mapstructure:"supplementalGroupsPolicy,omitempty"`

	// Sysctls corresponds to the JSON schema field "sysctls".
	Sysctls []KafkaBridgeSpecTemplatePodSecurityContextSysctlsElem `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`

	// WindowsOptions corresponds to the JSON schema field "windowsOptions".
	WindowsOptions *KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions `json:"windowsOptions,omitempty" yaml:"windowsOptions,omitempty" mapstructure:"windowsOptions,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodSecurityContextAppArmorProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions struct {
	// Level corresponds to the JSON schema field "level".
	Level *string `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Role corresponds to the JSON schema field "role".
	Role *string `json:"role,omitempty" yaml:"role,omitempty" mapstructure:"role,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// User corresponds to the JSON schema field "user".
	User *string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodSecurityContextSeccompProfile struct {
	// LocalhostProfile corresponds to the JSON schema field "localhostProfile".
	LocalhostProfile *string `json:"localhostProfile,omitempty" yaml:"localhostProfile,omitempty" mapstructure:"localhostProfile,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodSecurityContextSysctlsElem struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions struct {
	// GmsaCredentialSpec corresponds to the JSON schema field "gmsaCredentialSpec".
	GmsaCredentialSpec *string `json:"gmsaCredentialSpec,omitempty" yaml:"gmsaCredentialSpec,omitempty" mapstructure:"gmsaCredentialSpec,omitempty"`

	// GmsaCredentialSpecName corresponds to the JSON schema field
	// "gmsaCredentialSpecName".
	GmsaCredentialSpecName *string `json:"gmsaCredentialSpecName,omitempty" yaml:"gmsaCredentialSpecName,omitempty" mapstructure:"gmsaCredentialSpecName,omitempty"`

	// HostProcess corresponds to the JSON schema field "hostProcess".
	HostProcess *bool `json:"hostProcess,omitempty" yaml:"hostProcess,omitempty" mapstructure:"hostProcess,omitempty"`

	// RunAsUserName corresponds to the JSON schema field "runAsUserName".
	RunAsUserName *string `json:"runAsUserName,omitempty" yaml:"runAsUserName,omitempty" mapstructure:"runAsUserName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodTolerationsElem struct {
	// Effect corresponds to the JSON schema field "effect".
	Effect *string `json:"effect,omitempty" yaml:"effect,omitempty" mapstructure:"effect,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// TolerationSeconds corresponds to the JSON schema field "tolerationSeconds".
	TolerationSeconds *int32 `json:"tolerationSeconds,omitempty" yaml:"tolerationSeconds,omitempty" mapstructure:"tolerationSeconds,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodTopologySpreadConstraintsElem struct {
	// LabelSelector corresponds to the JSON schema field "labelSelector".
	LabelSelector *KafkaBridgeSpecTemplatePodTopologySpreadConstraintsElemLabelSelector `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// MatchLabelKeys corresponds to the JSON schema field "matchLabelKeys".
	MatchLabelKeys []string `json:"matchLabelKeys,omitempty" yaml:"matchLabelKeys,omitempty" mapstructure:"matchLabelKeys,omitempty"`

	// MaxSkew corresponds to the JSON schema field "maxSkew".
	MaxSkew *int32 `json:"maxSkew,omitempty" yaml:"maxSkew,omitempty" mapstructure:"maxSkew,omitempty"`

	// MinDomains corresponds to the JSON schema field "minDomains".
	MinDomains *int32 `json:"minDomains,omitempty" yaml:"minDomains,omitempty" mapstructure:"minDomains,omitempty"`

	// NodeAffinityPolicy corresponds to the JSON schema field "nodeAffinityPolicy".
	NodeAffinityPolicy *string `json:"nodeAffinityPolicy,omitempty" yaml:"nodeAffinityPolicy,omitempty" mapstructure:"nodeAffinityPolicy,omitempty"`

	// NodeTaintsPolicy corresponds to the JSON schema field "nodeTaintsPolicy".
	NodeTaintsPolicy *string `json:"nodeTaintsPolicy,omitempty" yaml:"nodeTaintsPolicy,omitempty" mapstructure:"nodeTaintsPolicy,omitempty"`

	// TopologyKey corresponds to the JSON schema field "topologyKey".
	TopologyKey *string `json:"topologyKey,omitempty" yaml:"topologyKey,omitempty" mapstructure:"topologyKey,omitempty"`

	// WhenUnsatisfiable corresponds to the JSON schema field "whenUnsatisfiable".
	WhenUnsatisfiable *string `json:"whenUnsatisfiable,omitempty" yaml:"whenUnsatisfiable,omitempty" mapstructure:"whenUnsatisfiable,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodTopologySpreadConstraintsElemLabelSelector struct {
	// MatchExpressions corresponds to the JSON schema field "matchExpressions".
	MatchExpressions []KafkaBridgeSpecTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem `json:"matchExpressions,omitempty" yaml:"matchExpressions,omitempty" mapstructure:"matchExpressions,omitempty"`

	// MatchLabels corresponds to the JSON schema field "matchLabels".
	MatchLabels map[string]string `json:"matchLabels,omitempty" yaml:"matchLabels,omitempty" mapstructure:"matchLabels,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodTopologySpreadConstraintsElemLabelSelectorMatchExpressionsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Operator corresponds to the JSON schema field "operator".
	Operator *string `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// Values corresponds to the JSON schema field "values".
	Values []string `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElem struct {
	// `ConfigMap` to use to populate the volume.
	ConfigMap *KafkaBridgeSpecTemplatePodVolumesElemConfigMap `json:"configMap,omitempty" yaml:"configMap,omitempty" mapstructure:"configMap,omitempty"`

	// `CSIVolumeSource` object to use to populate the volume.
	Csi *KafkaBridgeSpecTemplatePodVolumesElemCsi `json:"csi,omitempty" yaml:"csi,omitempty" mapstructure:"csi,omitempty"`

	// `EmptyDir` to use to populate the volume.
	EmptyDir *KafkaBridgeSpecTemplatePodVolumesElemEmptyDir `json:"emptyDir,omitempty" yaml:"emptyDir,omitempty" mapstructure:"emptyDir,omitempty"`

	// `ImageVolumeSource` object to use to populate the volume.
	Image *KafkaBridgeSpecTemplatePodVolumesElemImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Name to use for the volume. Required.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// `PersistentVolumeClaim` object to use to populate the volume.
	PersistentVolumeClaim *KafkaBridgeSpecTemplatePodVolumesElemPersistentVolumeClaim `json:"persistentVolumeClaim,omitempty" yaml:"persistentVolumeClaim,omitempty" mapstructure:"persistentVolumeClaim,omitempty"`

	// `Secret` to use to populate the volume.
	Secret *KafkaBridgeSpecTemplatePodVolumesElemSecret `json:"secret,omitempty" yaml:"secret,omitempty" mapstructure:"secret,omitempty"`
}

// `ConfigMap` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemConfigMap struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty" yaml:"defaultMode,omitempty" mapstructure:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaBridgeSpecTemplatePodVolumesElemConfigMapItemsElem `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemConfigMapItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

// `CSIVolumeSource` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemCsi struct {
	// Driver corresponds to the JSON schema field "driver".
	Driver *string `json:"driver,omitempty" yaml:"driver,omitempty" mapstructure:"driver,omitempty"`

	// FsType corresponds to the JSON schema field "fsType".
	FsType *string `json:"fsType,omitempty" yaml:"fsType,omitempty" mapstructure:"fsType,omitempty"`

	// NodePublishSecretRef corresponds to the JSON schema field
	// "nodePublishSecretRef".
	NodePublishSecretRef *KafkaBridgeSpecTemplatePodVolumesElemCsiNodePublishSecretRef `json:"nodePublishSecretRef,omitempty" yaml:"nodePublishSecretRef,omitempty" mapstructure:"nodePublishSecretRef,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`

	// VolumeAttributes corresponds to the JSON schema field "volumeAttributes".
	VolumeAttributes map[string]string `json:"volumeAttributes,omitempty" yaml:"volumeAttributes,omitempty" mapstructure:"volumeAttributes,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemCsiNodePublishSecretRef struct {
	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// `EmptyDir` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemEmptyDir struct {
	// Medium corresponds to the JSON schema field "medium".
	Medium *string `json:"medium,omitempty" yaml:"medium,omitempty" mapstructure:"medium,omitempty"`

	// SizeLimit corresponds to the JSON schema field "sizeLimit".
	SizeLimit *KafkaBridgeSpecTemplatePodVolumesElemEmptyDirSizeLimit `json:"sizeLimit,omitempty" yaml:"sizeLimit,omitempty" mapstructure:"sizeLimit,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemEmptyDirSizeLimit struct {
	// Amount corresponds to the JSON schema field "amount".
	Amount *string `json:"amount,omitempty" yaml:"amount,omitempty" mapstructure:"amount,omitempty"`

	// Format corresponds to the JSON schema field "format".
	Format *string `json:"format,omitempty" yaml:"format,omitempty" mapstructure:"format,omitempty"`
}

// `ImageVolumeSource` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemImage struct {
	// PullPolicy corresponds to the JSON schema field "pullPolicy".
	PullPolicy *string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Reference corresponds to the JSON schema field "reference".
	Reference *string `json:"reference,omitempty" yaml:"reference,omitempty" mapstructure:"reference,omitempty"`
}

// `PersistentVolumeClaim` object to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemPersistentVolumeClaim struct {
	// ClaimName corresponds to the JSON schema field "claimName".
	ClaimName *string `json:"claimName,omitempty" yaml:"claimName,omitempty" mapstructure:"claimName,omitempty"`

	// ReadOnly corresponds to the JSON schema field "readOnly".
	ReadOnly *bool `json:"readOnly,omitempty" yaml:"readOnly,omitempty" mapstructure:"readOnly,omitempty"`
}

// `Secret` to use to populate the volume.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemSecret struct {
	// DefaultMode corresponds to the JSON schema field "defaultMode".
	DefaultMode *int32 `json:"defaultMode,omitempty" yaml:"defaultMode,omitempty" mapstructure:"defaultMode,omitempty"`

	// Items corresponds to the JSON schema field "items".
	Items []KafkaBridgeSpecTemplatePodVolumesElemSecretItemsElem `json:"items,omitempty" yaml:"items,omitempty" mapstructure:"items,omitempty"`

	// Optional corresponds to the JSON schema field "optional".
	Optional *bool `json:"optional,omitempty" yaml:"optional,omitempty" mapstructure:"optional,omitempty"`

	// SecretName corresponds to the JSON schema field "secretName".
	SecretName *string `json:"secretName,omitempty" yaml:"secretName,omitempty" mapstructure:"secretName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplatePodVolumesElemSecretItemsElem struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Mode corresponds to the JSON schema field "mode".
	Mode *int32 `json:"mode,omitempty" yaml:"mode,omitempty" mapstructure:"mode,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTemplatePod) UnmarshalJSON(value []byte) error {
	type Plain KafkaBridgeSpecTemplatePod
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.TerminationGracePeriodSeconds != nil && 0 > *plain.TerminationGracePeriodSeconds {
		return fmt.Errorf("field %s: must be >= %v", "terminationGracePeriodSeconds", 0)
	}
	if plain.TmpDirSizeLimit != nil {
		if matched, _ := regexp.MatchString(`^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$`, string(*plain.TmpDirSizeLimit)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "TmpDirSizeLimit", `^([0-9.]+)([eEinumkKMGTP]*[-+]?[0-9]*)$`)
		}
	}
	*j = KafkaBridgeSpecTemplatePod(plain)
	return nil
}

// Template for the Kafka Bridge service account.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateServiceAccount struct {
	// Metadata applied to the resource.
	Metadata *KafkaBridgeSpecTemplateServiceAccountMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Metadata applied to the resource.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTemplateServiceAccountMetadata struct {
	// Annotations added to the Kubernetes resource.
	Annotations map[string]string `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels added to the Kubernetes resource.
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// TLS configuration for connecting Kafka Bridge to the cluster.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTls struct {
	// Trusted certificates for TLS connection.
	TrustedCertificates []KafkaBridgeSpecTlsTrustedCertificatesElem `json:"trustedCertificates,omitempty" yaml:"trustedCertificates,omitempty" mapstructure:"trustedCertificates,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeSpecTlsTrustedCertificatesElem struct {
	// The name of the file certificate in the secret.
	Certificate *string `json:"certificate,omitempty" yaml:"certificate,omitempty" mapstructure:"certificate,omitempty"`

	// Pattern for the certificate files in the secret. Use the
	// link:https://en.wikipedia.org/wiki/Glob_(programming)[_glob syntax_] for the
	// pattern. All files in the secret that match the pattern are used.
	Pattern *string `json:"pattern,omitempty" yaml:"pattern,omitempty" mapstructure:"pattern,omitempty"`

	// The name of the Secret containing the certificate.
	SecretName string `json:"secretName" yaml:"secretName" mapstructure:"secretName"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTlsTrustedCertificatesElem) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["secretName"]; raw != nil && !ok {
		return fmt.Errorf("field secretName in KafkaBridgeSpecTlsTrustedCertificatesElem: required")
	}
	type Plain KafkaBridgeSpecTlsTrustedCertificatesElem
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecTlsTrustedCertificatesElem(plain)
	return nil
}

// The configuration of tracing in Kafka Bridge.
// +kubebuilder:object:generate=true
type KafkaBridgeSpecTracing struct {
	// Type of the tracing used. Currently the only supported type is `opentelemetry`
	// for OpenTelemetry tracing. As of Strimzi 0.37.0, `jaeger` type is not supported
	// anymore and this option is ignored.
	Type KafkaBridgeSpecTracingType `json:"type" yaml:"type" mapstructure:"type"`
}

type KafkaBridgeSpecTracingType string

const KafkaBridgeSpecTracingTypeJaeger KafkaBridgeSpecTracingType = "jaeger"
const KafkaBridgeSpecTracingTypeOpentelemetry KafkaBridgeSpecTracingType = "opentelemetry"

var enumValues_KafkaBridgeSpecTracingType = []interface{}{
	"jaeger",
	"opentelemetry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTracingType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaBridgeSpecTracingType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaBridgeSpecTracingType, v)
	}
	*j = KafkaBridgeSpecTracingType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpecTracing) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in KafkaBridgeSpecTracing: required")
	}
	type Plain KafkaBridgeSpecTracing
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = KafkaBridgeSpecTracing(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaBridgeSpec) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["bootstrapServers"]; raw != nil && !ok {
		return fmt.Errorf("field bootstrapServers in KafkaBridgeSpec: required")
	}
	type Plain KafkaBridgeSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Replicas != nil && 0 > *plain.Replicas {
		return fmt.Errorf("field %s: must be >= %v", "replicas", 0)
	}
	*j = KafkaBridgeSpec(plain)
	return nil
}

// The status of the Kafka Bridge.
// +kubebuilder:object:generate=true
type KafkaBridgeStatus struct {
	// List of status conditions.
	Conditions []KafkaBridgeStatusConditionsElem `json:"conditions,omitempty" yaml:"conditions,omitempty" mapstructure:"conditions,omitempty"`

	// Label selector for pods providing this resource.
	LabelSelector *string `json:"labelSelector,omitempty" yaml:"labelSelector,omitempty" mapstructure:"labelSelector,omitempty"`

	// The generation of the CRD that was last reconciled by the operator.
	ObservedGeneration *int32 `json:"observedGeneration,omitempty" yaml:"observedGeneration,omitempty" mapstructure:"observedGeneration,omitempty"`

	// The current number of pods being used to provide this resource.
	Replicas *int32 `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// The URL at which external client applications can access the Kafka Bridge.
	Url *string `json:"url,omitempty" yaml:"url,omitempty" mapstructure:"url,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaBridgeStatusConditionsElem struct {
	// Last time the condition of a type changed from one status to another. The
	// required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
	LastTransitionTime *string `json:"lastTransitionTime,omitempty" yaml:"lastTransitionTime,omitempty" mapstructure:"lastTransitionTime,omitempty"`

	// Human-readable message indicating details about the condition's last
	// transition.
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// The reason for the condition's last transition (a single word in CamelCase).
	Reason *string `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// The status of the condition, either True, False or Unknown.
	Status *string `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`

	// The unique identifier of a condition, used to distinguish between other
	// conditions in the resource.
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}
