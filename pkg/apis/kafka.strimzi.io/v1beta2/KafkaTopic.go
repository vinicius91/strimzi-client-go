// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1beta2

import (
	"encoding/json"
	"fmt"
	"reflect"

	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// KafkaTopic
type KafkaTopic struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	// The specification of the topic.
	Spec *KafkaTopicSpec `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`

	// The status of the topic.
	Status *KafkaTopicStatus `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`
}

// +kubebuilder:object:root=true
// KafkaTopicList contains a list of KafkaTopic instances.
type KafkaTopicList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`

	// A list of KafkaTopic objects.
	Items []KafkaTopic `json:"items,omitempty"`
}

// The specification of the topic.
// +kubebuilder:object:generate=true
type KafkaTopicSpec struct {
	// The topic configuration.
	Config *apiextensions.JSON `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// The number of partitions the topic should have. This cannot be decreased after
	// topic creation. It can be increased after topic creation, but it is important
	// to understand the consequences that has, especially for topics with semantic
	// partitioning. When absent this will default to the broker configuration for
	// `num.partitions`.
	Partitions *int32 `json:"partitions,omitempty" yaml:"partitions,omitempty" mapstructure:"partitions,omitempty"`

	// The number of replicas the topic should have. When absent this will default to
	// the broker configuration for `default.replication.factor`.
	Replicas *int32 `json:"replicas,omitempty" yaml:"replicas,omitempty" mapstructure:"replicas,omitempty"`

	// The name of the topic. When absent this will default to the metadata.name of
	// the topic. It is recommended to not set this unless the topic name is not a
	// valid Kubernetes resource name.
	TopicName *string `json:"topicName,omitempty" yaml:"topicName,omitempty" mapstructure:"topicName,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaTopicSpec) UnmarshalJSON(value []byte) error {
	type Plain KafkaTopicSpec
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Partitions != nil && 1 > *plain.Partitions {
		return fmt.Errorf("field %s: must be >= %v", "partitions", 1)
	}
	if plain.Replicas != nil && 32767 < *plain.Replicas {
		return fmt.Errorf("field %s: must be <= %v", "replicas", 32767)
	}
	if plain.Replicas != nil && 1 > *plain.Replicas {
		return fmt.Errorf("field %s: must be >= %v", "replicas", 1)
	}
	*j = KafkaTopicSpec(plain)
	return nil
}

// The status of the topic.
// +kubebuilder:object:generate=true
type KafkaTopicStatus struct {
	// List of status conditions.
	Conditions []KafkaTopicStatusConditionsElem `json:"conditions,omitempty" yaml:"conditions,omitempty" mapstructure:"conditions,omitempty"`

	// The generation of the CRD that was last reconciled by the operator.
	ObservedGeneration *int32 `json:"observedGeneration,omitempty" yaml:"observedGeneration,omitempty" mapstructure:"observedGeneration,omitempty"`

	// Replication factor change status.
	ReplicasChange *KafkaTopicStatusReplicasChange `json:"replicasChange,omitempty" yaml:"replicasChange,omitempty" mapstructure:"replicasChange,omitempty"`

	// The topic's id. For a KafkaTopic with the ready condition, this will change
	// only if the topic gets deleted and recreated with the same name.
	TopicId *string `json:"topicId,omitempty" yaml:"topicId,omitempty" mapstructure:"topicId,omitempty"`

	// Topic name.
	TopicName *string `json:"topicName,omitempty" yaml:"topicName,omitempty" mapstructure:"topicName,omitempty"`
}

// +kubebuilder:object:generate=true
type KafkaTopicStatusConditionsElem struct {
	// Last time the condition of a type changed from one status to another. The
	// required format is 'yyyy-MM-ddTHH:mm:ssZ', in the UTC time zone.
	LastTransitionTime *string `json:"lastTransitionTime,omitempty" yaml:"lastTransitionTime,omitempty" mapstructure:"lastTransitionTime,omitempty"`

	// Human-readable message indicating details about the condition's last
	// transition.
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// The reason for the condition's last transition (a single word in CamelCase).
	Reason *string `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// The status of the condition, either True, False or Unknown.
	Status *string `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`

	// The unique identifier of a condition, used to distinguish between other
	// conditions in the resource.
	Type *string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Replication factor change status.
// +kubebuilder:object:generate=true
type KafkaTopicStatusReplicasChange struct {
	// Message for the user related to the replicas change request. This may contain
	// transient error messages that would disappear on periodic reconciliations.
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// The session identifier for replicas change requests pertaining to this
	// KafkaTopic resource. This is used by the Topic Operator to track the status of
	// `ongoing` replicas change operations.
	SessionId *string `json:"sessionId,omitempty" yaml:"sessionId,omitempty" mapstructure:"sessionId,omitempty"`

	// Current state of the replicas change operation. This can be `pending`, when the
	// change has been requested, or `ongoing`, when the change has been successfully
	// submitted to Cruise Control.
	State *KafkaTopicStatusReplicasChangeState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// The target replicas value requested by the user. This may be different from
	// .spec.replicas when a change is ongoing.
	TargetReplicas *int32 `json:"targetReplicas,omitempty" yaml:"targetReplicas,omitempty" mapstructure:"targetReplicas,omitempty"`
}

type KafkaTopicStatusReplicasChangeState string

const KafkaTopicStatusReplicasChangeStateOngoing KafkaTopicStatusReplicasChangeState = "ongoing"
const KafkaTopicStatusReplicasChangeStatePending KafkaTopicStatusReplicasChangeState = "pending"

var enumValues_KafkaTopicStatusReplicasChangeState = []interface{}{
	"pending",
	"ongoing",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *KafkaTopicStatusReplicasChangeState) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_KafkaTopicStatusReplicasChangeState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_KafkaTopicStatusReplicasChangeState, v)
	}
	*j = KafkaTopicStatusReplicasChangeState(v)
	return nil
}
